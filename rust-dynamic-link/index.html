<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>12101111&#x27;s blog - Rust动态链接</title>

      
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://12101111.github.io/rss.xml">
      

      
    <script src="https://12101111.github.io/slideout.min.js"></script>


      
          <link rel="stylesheet" href="https://12101111.github.io/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Coding...</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;12101111.github.io">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;12101111.github.io">Coding...</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;12101111.github.io">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://12101111.github.io/rust-dynamic-link/#cratelei-xing-yu-lian-jie" class="toc-link">crate类型与链接</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#bin" class="toc-link">bin</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#lib" class="toc-link">lib</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#cdylib" class="toc-link">cdylib</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#staticlib" class="toc-link">staticlib</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#rlib-or-dylib" class="toc-link">rlib or dylib</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#lian-jie-shi-yi-jian-fu-za-de-shi-qing" class="toc-link">链接是一件复杂的事情</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#cargohe-rustcde-shu-chu-wen-jian" class="toc-link">cargo和rustc的输出文件</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#dong-tai-lian-jie" class="toc-link">动态链接</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#dong-tai-lian-jie-de-rustcheng-xu-neng-fou-gong-xiang-yi-lai" class="toc-link">动态链接的rust程序能否共享依赖</a>
                        </li>
                        
                        <li>
                            <a href="https://12101111.github.io/rust-dynamic-link/#dong-tai-sheng-ji" class="toc-link">动态升级</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;rust-dynamic-link&#x2F;">Rust动态链接</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-01-05</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>本文探讨一下Rust的crate类型的概念, 以及如何在Rust中使用动态链接编译动态库. 同时对比rust编译出的动态库和使用C语言接口动态库, 看看rust动态库是否能实现C语言接口动态库的功能.</p>
<span id="continue-reading"></span><h1 id="cratelei-xing-yu-lian-jie">crate类型与链接</h1>
<p>crate type是一个rustc的概念,而不是rust语言或者是cargo的概念. 由于大多数rust项目使用<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">标准的文件目录结构</a>,而cargo会<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery">自动推测目标的类型</a>, 因此并不需要手动设置crate类型. 如果需要的话(例如编写proc-macro), 则需要在<code>Cargo.toml</code>中<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html">设置</a>.</p>
<p>此外,不使用cargo时, 通过rustc也可以指定crate类型, 一种方式是命令行, 例如<code>rustc --crate-type=bin</code>, 另一种是<code>crate_type</code>属性(built-in attribute), 需要指定在文档的开头, 例如<code>!#[crate_type = &quot;bin&quot;]</code>.如果二者同时使用, 命令行指定的值优先.实际上rustc正是使用命令行参数告诉rustc crate的类型.</p>
<p>rustc支持7种crate类型, 在源码中, crate类型是定义在<code>enum CrateType</code>中的(<a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/crate_type.rs">cargo的类型定义</a>, <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_session/src/config.rs#L707">rustc的类型定义</a>)</p>
<p><a href="https://doc.rust-lang.org/reference/linkage.html">rust reference</a>,给出了这7种类型的区别.</p>
<h2 id="bin"><code>bin</code></h2>
<p><code>bin</code> crate 会编译为一个可运行的二进制文件.<code>bin</code>类型不能作为其他crate的依赖, 并且通常会编译为一个可以运行的二进制程序, 通常包含一个<code>main</code>函数作为开始运行的入口点. 在上一篇文章我介绍了一些奇怪没有<code>main</code>函数的<code>bin</code>类型的crate.编译脚本(<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Build Scripts</a>, 通常为build.rs)也是一个单独的<code>bin</code> crate, 并在编译主crate前编译并运行.</p>
<h2 id="lib"><code>lib</code></h2>
<p><code>lib</code> crate泛指不是<code>bin</code>类型的crate, 其不会编译为二进制程序, 且不必包含<code>main</code>函数(你要愿意的话, 你可以写一个main函数, 仅仅是一个叫<code>mian</code>的函数而已), 且可以作为其他crate的依赖.</p>
<p>至于最终<code>lib</code> crate会编译出什么, 则会根据依赖它的crate决定.</p>
<h3 id="rlib"><code>rlib</code></h3>
<p><code>rlib</code>即rust静态库, 这是一个rustc和cargo使用的中间格式, 虽然和Unix archive(ar文件)格式相同, 但其中的存储的目标文件(<code>.o</code>)包含了rustc生成的元数据(rmeta), 根据这些元数据, rlib可以链接到其他rust库, 并产生其他格式的输出.<code>rlib</code>并不包括其依赖的代码, rustc会通过rlib中的元数据查找依赖.</p>
<h3 id="dylib"><code>dylib</code></h3>
<p>dylib用于将该依赖编译为动态库, 这样依赖其的<code>bin</code>类型crate会在运行前由操作系统的动态库加载器加载该依赖.其产生的文件扩展名在Linux上为<code>so</code>, Windows上为<code>dll</code>, macOS/iOS上为<code>dylib</code>, 且Linux的文件名具有<code>lib</code>的前缀.</p>
<p>我们随后会发现rust生成的dylib和C语言库略有不同, 这导致其用法也发生了很大的变化.在目前, <code>dylib</code>几乎只能作为cargo编译的中间产物使用, 就像rlib一样.</p>
<h2 id="cdylib"><code>cdylib</code></h2>
<p>cdylib是一种动态库, 与<code>dylib</code>不同的是, cdylib是为其他语言提供的动态库, 因此cdylib会静态链接rust的标准库, 以及递归的静态链接该crate的所有依赖, 这样输出的动态库只会暴露库所声明的符号, 不会依赖标准库的符号.<code>cdylib</code>和<code>bin</code>类型一样, 是最终产物, 因此不能作为rust的依赖出现.<code>cdylib</code>会最终作为其他语言(如C/C++)编写的可执行程序的动态库依赖, 或者被其他语言(如Python)以<code>dlopen</code>等动态加载的方式加载.cdylib输出的扩展名与dylib相同.</p>
<h2 id="staticlib"><code>staticlib</code></h2>
<p><code>staticlib</code>是一种静态库, 与<code>rlib</code>不同的是, <code>staticlib</code>是为其他语言提供的静态库, 因此和<code>cdylib</code>一样, <code>staticlib</code>会会静态链接rust的标准库, 以及递归的静态链接该crate的所有依赖.其产生的文件扩展名在Linux和macOS上为<code>.a</code>, 在Windows上为<code>.lib</code>, 且Linux的文件名具有<code>lib</code>的前缀.</p>
<h3 id="proc-macro">proc-macro</h3>
<p><code>proc-macro</code>是<a href="https://doc.rust-lang.org/reference/procedural-macros.html">过程宏</a>编译的产物, 其总是会静态链接到<code>libstd</code>, <code>proc_macro</code>, 且只能以和<code>rustc</code>相同的架构编译.除去链接的特殊性, <code>proc-macro</code>和cdylib非常类似.</p>
<p>在<code>proc_macro</code>crate中有一套基于C ABI的服务端(rustc前端)和客户端(即proc-macro动态库)相互通信的设施, 这样即使二者使用不同的rust ABI, 只要来自于同一份代码(即源码级兼容), 就可以相互调用.</p>
<h2 id="rlib-or-dylib">rlib or dylib</h2>
<p>可以看到, 实际上只有rlib和dylib两种库可以作为其他rust crate的依赖形式.与c语言风格的静态库(staticlib)和动态库(cdylib)不同的是, rlib和dylib虽然仍是Unix archive和so文件, 但是嵌入了rustc的meta data(rmeta文件)</p>
<p>rustc采用一种复杂的手段确定链接一个rust依赖的哪一种形式的库.(我们这里只讨论rust的库和依赖, C依赖只能通过build.rs修改LDFLAGS链接, 因此不做讨论)</p>
<ol>
<li>如果要产生一个staticlib, 那么其依赖只能使用<code>rlib</code>库, 因此已经编译成为<code>dylib</code>后就不能再转换为<code>rlib</code>了. staticlib是一个最终输出的目标, 因此该crate的所有递归依赖都需要是rlib, 如果不满足该条件, 则编译失败.</li>
<li>如果要产生一个rlib, 那么其依赖可以是rlib或dylib. 这时候这个crate实际上是作为其他crate的依赖(rlib本身并没有什么用处)</li>
<li>如果要产生一个bin, 且没有设置<code>-C prefer-dynamic</code>选项, 则首先使用rlib编译其依赖(即默认为静态链接), 如果其依赖不能作为rlib编译(例如某个依赖设置`crate_type=dylib), 则需要同时混合rlib和dylib.</li>
<li>如果要生成dylib, cdylib, 非静态链接的bin, 那么就需要混合链接dylib和rlib, 此时会遇到一个问题: 如果依赖图中2个dylib动态链接1个dylib, 这时合法的, 但是如果2个dylib静态链接同1个rlib, 随后再动态链接这两个dylib时就会出错, 因为这两个dylib提供了重复的符号.这时rustc会使用贪心算法判断将一个依赖编译为rlib还是dylib, 其策略为: 被两个dylib依赖的也是dylib, 其他的是rlib.</li>
</ol>
<p>https://doc.rust-lang.org/nightly/nightly-rustc/rustc_metadata/dependency_format/index.html</p>
<h2 id="lian-jie-shi-yi-jian-fu-za-de-shi-qing">链接是一件复杂的事情</h2>
<p>虽然Cargo给用户提供了一个友好的界面来管理依赖, 但背后的rustc却隐藏着复杂的细节. 这使得rustc相较于C编译器更加复杂.</p>
<p>在C/C++编译器中:</p>
<ul>
<li>编译一个动态库: <code>gcc -shared -o libabc.so abc.c</code></li>
<li>编译一个静态库: <code>ar rcs libabc.a a.o b.o c.o</code></li>
<li>依赖一个动态库: <code>gcc -o xyz -L/usr/local/lib -labc xyz.c</code></li>
<li>依赖一个静态库: <code>gcc -o xyz libabc.a xyz.c</code></li>
</ul>
<p>C语言使用动态库的主要动机是</p>
<ol>
<li>多个进程依赖同一个动态库时, 内存中只需要有一个动态库即可</li>
<li>动态库更新时不需要重新编译依赖它的程序</li>
</ol>
<p>我们随后会看到, rust至多只能实现1, 而2则是不能实现的.</p>
<h2 id="cargohe-rustcde-shu-chu-wen-jian">cargo和rustc的输出文件</h2>
<p>要想研究如何动态链接rust库, 我们先看看正常情况下</p>
<p>我们新建一个bin crate: <code>cargo new hello</code>和一个lib crate: <code>cargo new --lib mylib</code>, 将<code>mylib</code>添加到<code>hello</code>的依赖中: <code>mylib = { path=&quot;../mylib&quot; }</code></p>
<p>编译<code>hello</code>, 看看cargo为我们生成了什么</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; cd hello
</span><span>&gt; cargo build -v
</span><span>   Compiling mylib v0.1.0 (/tmp/rust/mylib)
</span><span>     Running `rustc --crate-name mylib --edition=2018 /tmp/rust/mylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=ff19b248b0012d99 -C extra-filename=-ff19b248b0012d99 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps -C target-feature=-crt-static`
</span><span>   Compiling hello v0.1.0 (/tmp/rust/hello)
</span><span>     Running `rustc --crate-name hello --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=0cf1e5265f244c28 -C extra-filename=-0cf1e5265f244c28 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib-ff19b248b0012d99.rlib -C target-feature=-crt-static`
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
</span><span>&gt; exa -T target --ignore-glob incremental
</span><span>target
</span><span>├── CACHEDIR.TAG
</span><span>└── debug
</span><span>   ├── build
</span><span>   ├── deps
</span><span>   │  ├── hello-0cf1e5265f244c28
</span><span>   │  ├── hello-0cf1e5265f244c28.d
</span><span>   │  ├── libmylib-ff19b248b0012d99.rlib
</span><span>   │  ├── libmylib-ff19b248b0012d99.rmeta
</span><span>   │  └── mylib-ff19b248b0012d99.d
</span><span>   ├── examples
</span><span>   ├── hello
</span><span>   └── hello.d
</span></code></pre>
<p><code>incremental</code>目录存放了增量式编译所存放的依赖图, 查询缓存, 编译出来的目标文件等文件, 通过rustc的<code>-C incremental=&lt;PATH&gt;</code>选项生成</p>
<p>d文件是纯文本文件, 使用类似makefile的格式记录了源码和中间文件的依赖关系, 通过rustc的<code>--emit=dep-info</code>选项生成.</p>
<p>例如 <code>target/debug/deps/hello-0cf1e5265f244c28.d</code>的内容:</p>
<pre data-lang="makefile" style="background-color:#fdf6e3;color:#657b83;" class="language-makefile "><code class="language-makefile" data-lang="makefile"><span style="color:#b58900;">/tmp/rust/hello/target/debug/deps/hello-0cf1e5265f244c28</span><span>: </span><span style="color:#2aa198;">src/main.rs
</span><span>  
</span><span style="color:#b58900;">/tmp/rust/hello/target/debug/deps/hello-0cf1e5265f244c28.d</span><span>: </span><span style="color:#2aa198;">src/main.rs
</span><span>
</span><span style="color:#b58900;">src/main.rs</span><span>:
</span></code></pre>
<p><code>target/debug/deps/mylib-ff19b248b0012d99.d</code>:</p>
<pre data-lang="makefile" style="background-color:#fdf6e3;color:#657b83;" class="language-makefile "><code class="language-makefile" data-lang="makefile"><span style="color:#b58900;">/tmp/rust/hello/target/debug/deps/mylib-ff19b248b0012d99.rmeta</span><span>: </span><span style="color:#2aa198;">/tmp/rust/mylib/src/lib.rs
</span><span>  
</span><span style="color:#b58900;">/tmp/rust/hello/target/debug/deps/libmylib-ff19b248b0012d99.rlib</span><span>: </span><span style="color:#2aa198;">/tmp/rust/mylib/src/lib.rs
</span><span>
</span><span style="color:#b58900;">/tmp/rust/hello/target/debug/deps/mylib-ff19b248b0012d99.d</span><span>: </span><span style="color:#2aa198;">/tmp/rust/mylib/src/lib.rs
</span><span>
</span><span style="color:#b58900;">/tmp/rust/mylib/src/lib.rs</span><span>:
</span></code></pre>
<p><code>target/debug/hello.d</code>:</p>
<pre data-lang="makefile" style="background-color:#fdf6e3;color:#657b83;" class="language-makefile "><code class="language-makefile" data-lang="makefile"><span style="color:#b58900;">/tmp/rust/hello/target/debug/hello</span><span>: </span><span style="color:#2aa198;">/tmp/rust/hello/src/main.rs /tmp/rust/mylib/src/lib.rs
</span></code></pre>
<p>rmeta文件是二进制的crate元数据文件, 通过rustc的<code>--emit=metadata</code>选项生成.</p>
<p>libmylib-ff19b248b0012d99.rlib是mylib这个库的最终编译出来的二进制文件, 由于cargo默认生成的lib crate只有一个单元测试, 因此该文件并不包括任何代码.前文提到, rlib实际上是Unix archive,因此可以使用readelf查看, 对于该rlib文件, 其中包括一个目标文件: <code>mylib-ff19b248b0012d99.1nemtrzp8kgtsf6b.rcgu.o</code></p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; readelf -a target/debug/deps/libmylib-ff19b248b0012d99.rlib
</span><span>
</span><span>File: target/debug/deps/libmylib-ff19b248b0012d99.rlib(mylib-ff19b248b0012d99.1nemtrzp8kgtsf6b.rcgu.o)
</span><span>ELF Header:
</span><span>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
</span><span>  Class:                             ELF64
</span><span>  Data:                              2&#39;s complement, little endian
</span><span>  Version:                           1 (current)
</span><span>  OS/ABI:                            UNIX - System V
</span><span>  ABI Version:                       0
</span><span>  Type:                              REL (Relocatable file)
</span><span>  Machine:                           Advanced Micro Devices X86-64
</span><span>  Version:                           0x1
</span><span>  Entry point address:               0x0
</span><span>  Start of program headers:          0 (bytes into file)
</span><span>  Start of section headers:          304 (bytes into file)
</span><span>  Flags:                             0x0
</span><span>  Size of this header:               64 (bytes)
</span><span>  Size of program headers:           0 (bytes)
</span><span>  Number of program headers:         0
</span><span>  Size of section headers:           64 (bytes)
</span><span>  Number of section headers:         7
</span><span>  Section header string table index: 1
</span><span>There are 7 section headers, starting at offset 0x130:
</span><span>
</span><span>Section Headers:
</span><span>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
</span><span>  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
</span><span>  [ 1] .strtab           STRTAB          0000000000000000 0000b0 00007e 00      0   0  1
</span><span>  [ 2] .text             PROGBITS        0000000000000000 000040 000000 00  AX  0   0  4
</span><span>  [ 3] .debug_gdb_scripts PROGBITS       0000000000000000 000040 000022 01 AMS  0   0  1
</span><span>  [ 4] .debug_aranges    PROGBITS        0000000000000000 000062 000000 00      0   0  1
</span><span>  [ 5] .note.GNU-stack   PROGBITS        0000000000000000 000062 000000 00      0   0  1
</span><span>  [ 6] .symtab           SYMTAB          0000000000000000 000068 000048 18      1   2  8
</span><span>Key to Flags:
</span><span>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
</span><span>  L (link order), O (extra OS processing required), G (group), T (TLS),
</span><span>  C (compressed), x (unknown), o (OS specific), E (exclude),
</span><span>  l (large), p (processor specific)
</span><span>
</span><span>Elf file type is REL (Relocatable file)
</span><span>Entry point 0x0
</span><span>There are 0 program headers, starting at offset 0
</span><span>
</span><span>Program Headers:
</span><span>  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
</span><span>
</span><span> Section to Segment mapping:
</span><span>  Segment Sections...
</span><span>   None   .strtab .text .debug_gdb_scripts .debug_aranges .note.GNU-stack .symtab
</span><span>
</span><span>There are no relocations in this file.
</span><span>
</span><span>Symbol table &#39;.symtab&#39; contains 3 entries:
</span><span>   Num:    Value          Size Type    Bind   Vis       Ndx Name
</span><span>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT   UND
</span><span>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT   ABS 1nemtrzp8kgtsf6b
</span><span>     2: 0000000000000000    34 OBJECT  WEAK   DEFAULT     3 __rustc_debug_gdb_scripts_section__
</span><span>There are no section groups in this file.
</span></code></pre>
<p>hello-0cf1e5265f244c28就是最终的二进制可执行程序, 观察第二个rustc的命令行, 可以发现rust的crate依赖是通过rustc的<code>--extern &lt;crate name&gt;=&lt;path to crate rlib&gt;</code>传递的.</p>
<p>deps目录中的16位ASCII后缀就是crate的metadata, 由cargo通过rustc的<code>-C metadata=&lt;HASH&gt; -C extra-filename=-&lt;HASH&gt;</code>选项传递.该hash包括了package id(crate 名称, 版本号, url), crate启用的features, 依赖的metadata, 编译时的profile和mode(如unwind设置, 优化级别, debug info 等), target名称和类型(本机编译还是交叉编译), rustc版本号.更多信息参考<a href="https://github.com/rust-lang/cargo/blob/2f218d0d1b3724d8ce9b3868f6b18d4b2ce5c9a5/src/cargo/core/compiler/context/compilation_files.rs#L489">计算metadata hash的cargo源码</a></p>
<p>我们注意到, 变更rustflags不会影响metadata的hash结果, 在不更改package id的情况下修改源代码也不会影响hash.而一旦一个crate的hash发生了变化, 所有依赖这个crate的hash也会变化.需要注意的是cargo并非通过metadata判断是否重编译crate, 而是通过<a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/fingerprint.rs">fingerprint</a>决定是否重编译.</p>
<p>有关更多cargo是如何调用rustc的信息, 可以查看<a href="https://github.com/rust-lang/cargo/blob/2f218d0d1b3724d8ce9b3868f6b18d4b2ce5c9a5/src/cargo/core/compiler/mod.rs#L771">cargo的源代码</a></p>
<p>更改两个crate的代码, 使得<code>hello</code>用到<code>mylib</code>的代码.</p>
<p><code>mylib/src/lib.rs</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">num</span><span>() -&gt; </span><span style="color:#268bd2;">i32 </span><span>{
</span><span>    </span><span style="color:#6c71c4;">1
</span><span>}
</span></code></pre>
<p><code>hello/src/main.rs</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">use </span><span>mylib::num;
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span>() {
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Hello, </span><span style="color:#cb4b16;">{}</span><span style="color:#2aa198;"> world!</span><span style="color:#839496;">&quot;</span><span>, </span><span style="color:#859900;">num</span><span>());
</span><span>}
</span></code></pre>
<p>再次编译并运行:</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; cargo build -v
</span><span>   Compiling mylib v0.1.0 (/tmp/rust/mylib)
</span><span>     Running `rustc --crate-name mylib --edition=2018 /tmp/rust/mylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=ff19b248b0012d99 -C extra-filename=-ff19b248b0012d99 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps -C target-feature=-crt-static`
</span><span>   Compiling hello v0.1.0 (/tmp/rust/hello)
</span><span>     Running `rustc --crate-name hello --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=0cf1e5265f244c28 -C extra-filename=-0cf1e5265f244c28 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib-ff19b248b0012d99.rlib -C target-feature=-crt-static`
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
</span><span>&gt; ./target/debug/hello
</span><span>Hello, 1 world!
</span></code></pre>
<p>可见更改代码的确不会变动metadata的hash值.</p>
<h2 id="dong-tai-lian-jie">动态链接</h2>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; RUSTFLAGS=&quot;-C prefer-dynamic -C target-feature=-crt-static&quot; cargo build -v
</span><span>   Compiling mylib v0.1.0 (/tmp/rust/mylib)
</span><span>     Running `rustc --crate-name mylib --edition=2018 /tmp/rust/mylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=ff19b248b0012d99 -C extra-filename=-ff19b248b0012d99 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps -C prefer-dynamic -C target-feature=-crt-static`
</span><span>   Compiling hello v0.1.0 (/tmp/rust/hello)
</span><span>     Running `rustc --crate-name hello --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=0cf1e5265f244c28 -C extra-filename=-0cf1e5265f244c28 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib-ff19b248b0012d99.rlib -C prefer-dynamic -C target-feature=-crt-static`
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
</span><span>&gt; exa -T target --ignore-glob incremental
</span><span>target
</span><span>├── CACHEDIR.TAG
</span><span>└── debug
</span><span>   ├── build
</span><span>   ├── deps
</span><span>   │  ├── hello-0cf1e5265f244c28
</span><span>   │  ├── hello-0cf1e5265f244c28.d
</span><span>   │  ├── libmylib-ff19b248b0012d99.rlib
</span><span>   │  ├── libmylib-ff19b248b0012d99.rmeta
</span><span>   │  └── mylib-ff19b248b0012d99.d
</span><span>   ├── examples
</span><span>   ├── hello
</span><span>   └── hello.d
</span><span>&gt; ./target/debug/hello
</span><span>Error loading shared library libstd-aef788a827ed39d9.so: No such file or directory (needed by ./target/debug/hello)
</span><span>Error relocating ./target/debug/hello: _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE: symbol not found
</span><span>Error relocating ./target/debug/hello: rust_eh_personality: symbol not found
</span><span>Error relocating ./target/debug/hello: _ZN3std2io5stdio6_print17h1ded803b1aed6cccE: symbol not found
</span><span>Error relocating ./target/debug/hello: _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E: symbol not found
</span><span>&gt; readelf -d target/debug/hello | grep NEEDED
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libstd-aef788a827ed39d9.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libgcc_s.so.1]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libc.so]
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib ./target/debug/hello
</span><span>Hello, 1 world!
</span></code></pre>
<p>这时生成的二进制程序依赖dylib版的libstd.根据前文提到的rustc决定依赖格式(也就是当<code>crate-type=lib</code>时<code>-C emit=link</code>时生成dylib还是rlib)的逻辑, 由于libstd是预编译且同时提供了rlib和dylib两种格式, 因为prefer-dynamic开关的存在, 选择dylib版的libstd, 而<code>mylib</code>没有编译(fingerprint发生变化,原来的编译文件无效), 既可以使用rlib也可以使用dylib, 且不依赖dylib, 因此自动选择了rlib, 因此 <code>mylib</code> 并没有编译为dylib.</p>
<p>查看std的<code>Cargo.toml</code>可以得知, 在<code>mylib</code>的<code>Cargo.toml</code>中加入</p>
<pre data-lang="toml" style="background-color:#fdf6e3;color:#657b83;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#b58900;">lib</span><span>]
</span><span style="color:#268bd2;">crate-type </span><span>= [</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">dylib</span><span style="color:#839496;">&quot;</span><span>, </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">rlib</span><span style="color:#839496;">&quot;</span><span>]
</span></code></pre>
<p>可以使得该crate可以编译为dylib或rlib, 且在prefer-dynamic存在时主动选择dylib</p>
<p>重编译<code>hello</code>并运行</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; RUSTFLAGS=&quot;-C prefer-dynamic -C target-feature=-crt-static&quot; cargo build -v
</span><span>   Compiling mylib v0.1.0 (/tmp/rust/mylib)
</span><span>     Running `rustc --crate-name mylib --edition=2018 /tmp/rust/mylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type dylib --crate-type rlib --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debuginfo=2 -C metadata=b6125a00ae42b63c --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps -C prefer-dynamic -C target-feature=-crt-static`
</span><span>   Compiling hello v0.1.0 (/tmp/rust/hello)
</span><span>     Running `rustc --crate-name hello --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=29d11507098fa904 -C extra-filename=-29d11507098fa904 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib.so --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib.rlib -C prefer-dynamic -C target-feature=-crt-static`
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
</span><span>&gt; exa -T target --ignore-glob incremental
</span><span>target
</span><span>├── CACHEDIR.TAG
</span><span>└── debug
</span><span>   ├── build
</span><span>   ├── deps
</span><span>   │  ├── hello-29d11507098fa904
</span><span>   │  ├── hello-29d11507098fa904.d
</span><span>   │  ├── libmylib.rlib
</span><span>   │  ├── libmylib.so
</span><span>   │  └── mylib.d
</span><span>   ├── examples
</span><span>   ├── hello
</span><span>   ├── hello.d
</span><span>   └── libmylib.so
</span><span>&gt; ./target/debug/hello
</span><span>Error loading shared library libmylib.so: No such file or directory (needed by ./target/debug/hello)
</span><span>Error loading shared library libstd-aef788a827ed39d9.so: No such file or directory (needed by ./target/debug/hello)
</span><span>Error relocating ./target/debug/hello: rust_eh_personality: symbol not found
</span><span>Error relocating ./target/debug/hello: _ZN3std2io5stdio6_print17h1ded803b1aed6cccE: symbol not found
</span><span>Error relocating ./target/debug/hello: _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E: symbol not found
</span><span>Error relocating ./target/debug/hello: _ZN5mylib3num17hefef8e0aa2fb2876E: symbol not found
</span><span>Error relocating ./target/debug/hello: _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE: symbol not found
</span><span>&gt; readelf -d target/debug/hello | grep NEEDED
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libmylib.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libstd-aef788a827ed39d9.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libgcc_s.so.1]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libc.so]
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug ./target/debug/hello
</span><span>Hello, 1 world!
</span></code></pre>
<p>(为什么在这里不使用cargo run? 因为使用cargo run可以直接运行, 不会报错找不到共享库文件, cargo设置了LD_LIBRARY_PATH, 但是并没有在输出中体现出来)</p>
<p>值得注意的是dylib的编译结果的文件名并不包括metadata hash, 但libstd因为并不是标准的cargo包因此较为特殊.</p>
<h2 id="dong-tai-lian-jie-de-rustcheng-xu-neng-fou-gong-xiang-yi-lai">动态链接的rust程序能否共享依赖</h2>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; mkdir src/bin
</span><span>&gt; cp src/main.rs src/bin/hi.rs
</span></code></pre>
<p>把<code>hi.rs</code> 稍作修改: <code>println!(&quot;Hello, {} world!&quot;, num() * 2);</code></p>
<pre data-lang="bash" style="background-color:#fdf6e3;color:#657b83;" class="language-bash "><code class="language-bash" data-lang="bash"><span>&gt; cargo </span><span style="color:#b58900;">clean
</span><span>&gt; RUSTFLAGS=</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">-C prefer-dynamic -C target-feature=-crt-static</span><span style="color:#839496;">&quot; </span><span style="color:#b58900;">cargo</span><span> build</span><span style="color:#268bd2;"> -v --bin</span><span> hello
</span><span>   </span><span style="color:#b58900;">Compiling</span><span> mylib v0.1.0 (/tmp/rust/mylib)
</span><span>     </span><span style="color:#b58900;">Running </span><span>`</span><span style="color:#b58900;">rustc</span><span style="color:#268bd2;"> --crate-name</span><span> mylib</span><span style="color:#268bd2;"> --edition</span><span>=2018 /tmp/rust/mylib/src/lib.rs</span><span style="color:#268bd2;"> --error-format</span><span>=json</span><span style="color:#268bd2;"> --json</span><span>=diagnostic-rendered-ansi</span><span style="color:#268bd2;"> --crate-type</span><span> dylib</span><span style="color:#268bd2;"> --crate-type</span><span> rlib</span><span style="color:#268bd2;"> --emit</span><span>=dep-info,link</span><span style="color:#268bd2;"> -C</span><span> prefer-dynamic</span><span style="color:#268bd2;"> -C</span><span> embed-bitcode=no</span><span style="color:#268bd2;"> -C</span><span> debuginfo=2</span><span style="color:#268bd2;"> -C</span><span> metadata=b6125a00ae42b63c</span><span style="color:#268bd2;"> --out-dir</span><span> /tmp/rust/hello/target/debug/deps</span><span style="color:#268bd2;"> -C</span><span> incremental=/tmp/rust/hello/target/debug/incremental</span><span style="color:#268bd2;"> -L</span><span> dependency=/tmp/rust/hello/target/debug/deps</span><span style="color:#268bd2;"> -C</span><span> prefer-dynamic</span><span style="color:#268bd2;"> -C</span><span> target-feature=-crt-static`
</span><span>   </span><span style="color:#b58900;">Compiling</span><span> hello v0.1.0 (/tmp/rust/hello)
</span><span>     </span><span style="color:#b58900;">Running </span><span>`</span><span style="color:#b58900;">rustc</span><span style="color:#268bd2;"> --crate-name</span><span> hello</span><span style="color:#268bd2;"> --edition</span><span>=2018 src/main.rs</span><span style="color:#268bd2;"> --error-format</span><span>=json</span><span style="color:#268bd2;"> --json</span><span>=diagnostic-rendered-ansi</span><span style="color:#268bd2;"> --crate-type</span><span> bin</span><span style="color:#268bd2;"> --emit</span><span>=dep-info,link</span><span style="color:#268bd2;"> -C</span><span> embed-bitcode=no</span><span style="color:#268bd2;"> -C</span><span> debuginfo=2</span><span style="color:#268bd2;"> -C</span><span> metadata=29d11507098fa904</span><span style="color:#268bd2;"> -C</span><span> extra-filename=-29d11507098fa904</span><span style="color:#268bd2;"> --out-dir</span><span> /tmp/rust/hello/target/debug/deps</span><span style="color:#268bd2;"> -C</span><span> incremental=/tmp/rust/hello/target/debug/incremental</span><span style="color:#268bd2;"> -L</span><span> dependency=/tmp/rust/hello/target/debug/deps</span><span style="color:#268bd2;"> --extern</span><span> mylib=/tmp/rust/hello/target/debug/deps/libmylib.so</span><span style="color:#268bd2;"> --extern</span><span> mylib=/tmp/rust/hello/target/debug/deps/libmylib.rlib</span><span style="color:#268bd2;"> -C</span><span> prefer-dynamic</span><span style="color:#268bd2;"> -C</span><span> target-feature=-crt-static`
</span><span>    </span><span style="color:#b58900;">Finished</span><span> dev </span><span style="color:#859900;">[</span><span>unoptimized + debuginfo</span><span style="color:#859900;">]</span><span> target(s) </span><span style="color:#b58900;">in</span><span> 0.42s
</span><span>&gt; RUSTFLAGS=</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">-C prefer-dynamic -C target-feature=-crt-static</span><span style="color:#839496;">&quot; </span><span style="color:#b58900;">cargo</span><span> build</span><span style="color:#268bd2;"> -v --bin</span><span> hi
</span><span>       </span><span style="color:#b58900;">Fresh</span><span> mylib v0.1.0 (/tmp/rust/mylib)
</span><span>   </span><span style="color:#b58900;">Compiling</span><span> hello v0.1.0 (/tmp/rust/hello)
</span><span>     </span><span style="color:#b58900;">Running </span><span>`</span><span style="color:#b58900;">rustc</span><span style="color:#268bd2;"> --crate-name</span><span> hi</span><span style="color:#268bd2;"> --edition</span><span>=2018 src/bin/hi.rs</span><span style="color:#268bd2;"> --error-format</span><span>=json</span><span style="color:#268bd2;"> --json</span><span>=diagnostic-rendered-ansi</span><span style="color:#268bd2;"> --crate-type</span><span> bin</span><span style="color:#268bd2;"> --emit</span><span>=dep-info,link</span><span style="color:#268bd2;"> -C</span><span> embed-bitcode=no</span><span style="color:#268bd2;"> -C</span><span> debuginfo=2</span><span style="color:#268bd2;"> -C</span><span> metadata=24d23b4e455b3276</span><span style="color:#268bd2;"> -C</span><span> extra-filename=-24d23b4e455b3276</span><span style="color:#268bd2;"> --out-dir</span><span> /tmp/rust/hello/target/debug/deps</span><span style="color:#268bd2;"> -C</span><span> incremental=/tmp/rust/hello/target/debug/incremental</span><span style="color:#268bd2;"> -L</span><span> dependency=/tmp/rust/hello/target/debug/deps</span><span style="color:#268bd2;"> --extern</span><span> mylib=/tmp/rust/hello/target/debug/deps/libmylib.so</span><span style="color:#268bd2;"> --extern</span><span> mylib=/tmp/rust/hello/target/debug/deps/libmylib.rlib</span><span style="color:#268bd2;"> -C</span><span> prefer-dynamic</span><span style="color:#268bd2;"> -C</span><span> target-feature=-crt-static`
</span><span>    </span><span style="color:#b58900;">Finished</span><span> dev </span><span style="color:#859900;">[</span><span>unoptimized + debuginfo</span><span style="color:#859900;">]</span><span> target(s) </span><span style="color:#b58900;">in</span><span> 0.16s
</span><span>&gt; exa </span><span style="color:#b58900;">-T</span><span> target</span><span style="color:#268bd2;"> --ignore-glob</span><span> incremental
</span><span style="color:#b58900;">target
</span><span style="color:#b58900;">├──</span><span> CACHEDIR.TAG
</span><span style="color:#b58900;">└──</span><span> debug
</span><span>   </span><span style="color:#b58900;">├──</span><span> build
</span><span>   </span><span style="color:#b58900;">├──</span><span> deps
</span><span>   </span><span style="color:#b58900;">│</span><span>  ├── hello-29d11507098fa904
</span><span>   </span><span style="color:#b58900;">│</span><span>  ├── hello-29d11507098fa904.d
</span><span>   </span><span style="color:#b58900;">│</span><span>  ├── hi-24d23b4e455b3276
</span><span>   </span><span style="color:#b58900;">│</span><span>  ├── hi-24d23b4e455b3276.d
</span><span>   </span><span style="color:#b58900;">│</span><span>  ├── libmylib.rlib
</span><span>   </span><span style="color:#b58900;">│</span><span>  ├── libmylib.so
</span><span>   </span><span style="color:#b58900;">│</span><span>  └── mylib.d
</span><span>   </span><span style="color:#b58900;">├──</span><span> examples
</span><span>   </span><span style="color:#b58900;">├──</span><span> hello
</span><span>   </span><span style="color:#b58900;">├──</span><span> hello.d
</span><span>   </span><span style="color:#b58900;">├──</span><span> hi
</span><span>   </span><span style="color:#b58900;">├──</span><span> hi.d
</span><span>   </span><span style="color:#b58900;">└──</span><span> libmylib.so
</span><span>&gt; export </span><span style="color:#268bd2;">LD_LIBRARY_PATH</span><span>=</span><span style="color:#d33682;">~</span><span style="color:#2aa198;">/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug
</span><span>&gt; ./target/debug/hello
</span><span style="color:#b58900;">Hello,</span><span> 1 world!
</span><span>&gt; ./target/debug/hi
</span><span style="color:#b58900;">Hello,</span><span> 2 world!
</span></code></pre>
<p>注意到编译<code>hi</code>时, 输出的<code>Fresh mylib v0.1.0 (/tmp/rust/mylib)</code>表明cargo并没有重编译<code>mylib</code>.
最终这两个bin都可以正常运行, 我们看看它们是不是真的依赖libmylib.so</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; readelf -d target/debug/hello | grep NEEDED
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libmylib.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libstd-aef788a827ed39d9.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libgcc_s.so.1]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libc.so]
</span><span>&gt; readelf -d target/debug/hi | grep NEEDED
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libmylib.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libstd-aef788a827ed39d9.so]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libgcc_s.so.1]
</span><span>  0x0000000000000001 (NEEDED)       Shared library: [libc.so]
</span></code></pre>
<p>至少elf头中记录了hello和hi都需要<code>libmylib.so</code>和<code>libstd-aef788a827ed39d9.so</code>, 我们看看符号是否能对的上.使用nm工具查看3个elf的符号:</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; nm target/debug/libmylib.so
</span><span>0000000000002640 d _DYNAMIC
</span><span>00000000000015e0 T _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>00000000000004e0 r __EH_FRAME_LIST_END__
</span><span>                 w __cxa_finalize
</span><span>                 w __deregister_frame_info
</span><span>00000000000037f8 d __dso_handle
</span><span>                 w __register_frame_info
</span><span>0000000000000498 r __rustc_debug_gdb_scripts_section__
</span><span>00000000000015eb t _fini
</span><span>00000000000015e8 t _init
</span><span>0000000000000000 N rust_metadata_mylib_ee167d4ab2087d981bbef06aea3f858f
</span><span>&gt; nm target/debug/hello
</span><span>00000000000032e8 d DW.ref.rust_eh_personality
</span><span>00000000000008ac r GCC_except_table0
</span><span>00000000000008a0 r GCC_except_table2
</span><span>0000000000002060 d _DYNAMIC
</span><span>                 U _Unwind_Resume
</span><span>0000000000001e80 t _ZN3std10sys_common9backtrace28__rust_begin_short_backtrace17h1532b767e1a19115E
</span><span>                 U _ZN3std2io5stdio6_print17h1ded803b1aed6cccE
</span><span>0000000000001ec0 t _ZN3std2rt10lang_start17h393e70d55468c5deE
</span><span>0000000000001f20 t _ZN3std2rt10lang_start28_$u7b$$u7b$closure$u7d$$u7d$17h7c2fd3be77659b30E
</span><span>                 U _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE
</span><span>0000000000001f90 t _ZN3std3sys4unix7process14process_common8ExitCode6as_i3217h7a7beeee9da95e03E
</span><span>0000000000001d00 t _ZN4core3fmt10ArgumentV13new17h58403316e9e3aed8E
</span><span>                 U _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E
</span><span>0000000000001d60 t _ZN4core3fmt9Arguments6new_v117h641b32bcb1583909E
</span><span>0000000000001c80 t _ZN4core3ops8function6FnOnce40call_once$u7b$$u7b$vtable.shim$u7d$$u7d$17hebed9ec320856400E
</span><span>0000000000001ca0 t _ZN4core3ops8function6FnOnce9call_once17hd6f7e85eff99597aE
</span><span>0000000000001cb0 t _ZN4core3ops8function6FnOnce9call_once17he86a1358c035a351E
</span><span>0000000000001cf0 t _ZN4core3ptr13drop_in_place17hdc22de41e16c2f90E
</span><span>0000000000001db0 t _ZN4core4hint9black_box17h2501d3e9821f440dE
</span><span>0000000000001f50 t _ZN54_$LT$$LP$$RP$$u20$as$u20$std..process..Termination$GT$6report17h8dc214f9ad10d68aE
</span><span>0000000000001dc0 t _ZN5hello4main17h080ec7908287a1a0E
</span><span>                 U _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>0000000000001f70 t _ZN68_$LT$std..process..ExitCode$u20$as$u20$std..process..Termination$GT$6report17hc95702f5648ae8a0E
</span><span>0000000000000988 r __EH_FRAME_LIST_END__
</span><span>                 w __cxa_finalize
</span><span>                 w __deregister_frame_info
</span><span>00000000000032e0 d __dso_handle
</span><span>                 U __libc_start_main
</span><span>                 w __register_frame_info
</span><span>00000000000008bc V __rustc_debug_gdb_scripts_section__
</span><span>0000000000001f9d T _fini
</span><span>0000000000001f9a T _init
</span><span>0000000000001ba0 T _start
</span><span>0000000000001bc0 T _start_c
</span><span>0000000000001e50 T main
</span><span>                 U rust_eh_personality
</span><span>&gt; nm target/debug/hi
</span><span>00000000000043e8 d DW.ref.rust_eh_personality
</span><span>0000000000000950 r GCC_except_table0
</span><span>0000000000000944 r GCC_except_table1
</span><span>0000000000003158 d _DYNAMIC
</span><span>                 U _Unwind_Resume
</span><span>0000000000001e90 t _ZN2hi4main17h9e2072fe35c4b5b4E
</span><span>0000000000001fe0 t _ZN3std10sys_common9backtrace28__rust_begin_short_backtrace17he1d71d9db80c0530E
</span><span>                 U _ZN3std2io5stdio6_print17h1ded803b1aed6cccE
</span><span>0000000000001d80 t _ZN3std2rt10lang_start17hc99a7c63ea252eaeE
</span><span>0000000000001de0 t _ZN3std2rt10lang_start28_$u7b$$u7b$closure$u7d$$u7d$17h031e9375f8893238E
</span><span>                 U _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE
</span><span>0000000000002020 t _ZN3std3sys4unix7process14process_common8ExitCode6as_i3217h7189431738fbb130E
</span><span>0000000000001d20 t _ZN4core3fmt10ArgumentV13new17h86fc128822eafca9E
</span><span>                 U _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E
</span><span>0000000000002030 t _ZN4core3fmt9Arguments6new_v117h71ce12250f51dee7E
</span><span>0000000000001e10 t _ZN4core3ops8function6FnOnce40call_once$u7b$$u7b$vtable.shim$u7d$$u7d$17h98204e361d18157eE
</span><span>0000000000001e30 t _ZN4core3ops8function6FnOnce9call_once17h69c2245f11c57f2cE
</span><span>0000000000001e70 t _ZN4core3ops8function6FnOnce9call_once17h708925e4b9276646E
</span><span>0000000000001e80 t _ZN4core3ptr13drop_in_place17h0ea2467bdcaed3a3E
</span><span>0000000000001f90 t _ZN4core4hint9black_box17h9c97f0f64843d9bbE
</span><span>                 U _ZN4core9panicking5panic17h1c3c966b042834b6E
</span><span>0000000000001fa0 t _ZN54_$LT$$LP$$RP$$u20$as$u20$std..process..Termination$GT$6report17h5775a3587e9f1ccaE
</span><span>                 U _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>0000000000001fc0 t _ZN68_$LT$std..process..ExitCode$u20$as$u20$std..process..Termination$GT$6report17h37da287fc237aeb0E
</span><span>0000000000000a38 r __EH_FRAME_LIST_END__
</span><span>                 w __cxa_finalize
</span><span>                 w __deregister_frame_info
</span><span>00000000000043e0 d __dso_handle
</span><span>                 U __libc_start_main
</span><span>                 w __register_frame_info
</span><span>0000000000000920 V __rustc_debug_gdb_scripts_section__
</span><span>000000000000207b T _fini
</span><span>0000000000002078 T _init
</span><span>0000000000001c40 T _start
</span><span>0000000000001c60 T _start_c
</span><span>0000000000001f60 T main
</span><span>                 U rust_eh_personality
</span><span>0000000000000980 r str.0
</span></code></pre>
<p>这样看起来太乱了, 我们只关系so动态库定义的全局text段符号(T),和可执行程序未定义的符号(U)</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; nm target/debug/hi | grep U
</span><span>                 U _Unwind_Resume
</span><span>                 U _ZN3std2io5stdio6_print17h1ded803b1aed6cccE
</span><span>                 U _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE
</span><span>                 U _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E
</span><span>                 U _ZN4core9panicking5panic17h1c3c966b042834b6E
</span><span>                 U _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>                 U __libc_start_main
</span><span>                 U rust_eh_personality
</span><span>&gt; nm target/debug/hello| grep U
</span><span>                 U _Unwind_Resume
</span><span>                 U _ZN3std2io5stdio6_print17h1ded803b1aed6cccE
</span><span>                 U _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE
</span><span>                 U _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E
</span><span>                 U _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>                 U __libc_start_main
</span><span>                 U rust_eh_personality
</span><span>&gt; nm target/debug/libmylib.so| grep T
</span><span>00000000000015e0 T _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>00000000000004e0 r __EH_FRAME_LIST_END__
</span></code></pre>
<p><code>libmylib.so</code>提供的<code>_ZN5mylib3num17hefef8e0aa2fb2876E</code>符号的却是hello和hi未定义的符号, 非常正确.</p>
<p>用objdump查看该符号的反汇编</p>
<pre data-lang="s" style="background-color:#fdf6e3;color:#657b83;" class="language-s "><code class="language-s" data-lang="s"><span>00000000000015e0 &lt;_ZN5mylib3num17hefef8e0aa2fb2876E&gt;:
</span><span>    15e0: b8 01 00 00 00               	movl	$1, %eax
</span><span>    15e5: c3                           	retq
</span><span>    15e6: cc                           	int3
</span><span>    15e7: cc                           	int3
</span></code></pre>
<p>的确是我们要的那个函数.</p>
<p>到此我们可以做出结论, 使用dylib的确可以使其在多个rust bin之间共享, 只需要设置<code>crate-type = [&quot;dylib&quot;, ...]</code>即可.</p>
<p>实际上, rustc的主要部分位于<code>librustc_driver-&lt;hash&gt;.so</code>中, 其大小为数十到数百MB, 而<code>rustc</code>可执行程序仅为数MB, 只是一个命令行前端而已.而<code>librustc_driver</code>则被rustc, clippy-driver, rls, rustdoc等程序共享, 减小了整个编译器工具链的大小.</p>
<p>但是, 非常明显的问题就是, 我们不能让所有的crate动态链接, 只有那些在Cargo.toml特别设置的crate才能编译为dylib.这是一个小小的局限性.</p>
<h2 id="dong-tai-sheng-ji">动态升级</h2>
<p>另一个动态库的特性是动态库升级后, 如果没有发生break change导致ABI变化, 依赖其的程序/其他动态库不需要重编译.在Unix系统上, 这一机制通常使用soname实现. 例如webkit-gtk这个c/c++编写的浏览器引擎, 其文件为<code>/usr/lib/libwebkit2gtk-4.0.so.37.49.8</code>, 并且有符号链接<code>/usr/lib/libwebkit2gtk-4.0.so</code>和<code>/usr/lib/libwebkit2gtk-4.0.so.37</code>, 这里soname就是<code>.so</code>后面的<code>37.49.8</code>.webkit-gtk发生一个A BI稳定的升级后, 其soname可能增加, 例如变为<code>37.49.9</code>或<code>37.50.0</code>, 但依赖webkit-gtk的程序会使用<code>libwebkit2gtk-4.0.so.37</code>这个符号链接, 这样不需要修改程序, 就会自动调用新的webkit-gtk.</p>
<p>ABI是应用程序二进制接口(application binary interface)的缩写, 和API(application programming interface)类似又不同.API 是一个程序或库对开发者提供的一组接口, 包括了函数, 常量, 全局变量, 结构体, 枚举的定义, 这样开发者可以在不了解函数实现的前提下使用该程序和库.通常API稳定是指现有的函数名和签名不发生变化, 常量和全局变量名称不变, 结构体现有各个成员的名称和类型不变, 枚举现有各个成员的名称和类型不变, 且前面所述不变的各个项目语义没有发生变化. API稳定是源码级的, 即API稳定的库在升级后, 重新编译依赖其的程序, 就可以继续使用, 无需修改程序.而ABI稳定则更加严格, 常量的类型和值不能发生变化, 函数的符号和调用约定不能发生变化, 全局变量的符号和类型不能发生变化, 包括结构体和枚举在内的各个类型的类型大小、布局、对齐不能发生变化.</p>
<p>大家可能已经知道了, rust并没有一个稳定的ABI. 即使是定义完全相同的struct, 其布局也可能发生变化.</p>
<p>例如一个模拟标准库里的Vec:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">struct </span><span style="color:#b58900;">MyVec</span><span>{
</span><span>  </span><span style="color:#268bd2;">ptr</span><span>: Unique&lt;T&gt;,
</span><span>  </span><span style="color:#268bd2;">cap</span><span>: </span><span style="color:#268bd2;">usize</span><span>,
</span><span>  </span><span style="color:#268bd2;">len</span><span>: </span><span style="color:#268bd2;">usize
</span><span>}
</span></code></pre>
<p>实际上ptr, cap和len的顺序并不是声明的顺序, 且ptr和cap之间可能并不是连续的, 可能存在8 bytes的填充.而这个填充也可能在cap和len之间, 编译器会根据实际各个字段的使用情况对布局进行优化.正是因为这种不确定性, 一方面rustc会生成效率更高的代码,另一方面rust很难在不限制优化水平的情况下制定一个稳定的ABI. 实际上rust所有支持的调用约定中, 只有C调用约定是稳定的, 但这时布局优化就会时效, 很可能产生对内存和缓存不友好的代码.rust nomicon对rust默认的布局做出了解释: <a href="https://doc.rust-lang.org/nomicon/repr-rust.html">repr(Rust)</a>, rust reference则对<a href="https://doc.rust-lang.org/reference/type-layout.html">类型布局</a>有更详细的解释.</p>
<p>要使用C调用约定, 可以使用<code>#[repr(C)]</code>修饰结构体, 使用C语言函数调用约定的函数: <code>extern &quot;C&quot; fn&quot;</code>. nomicon也有详细的解释: <a href="https://doc.rust-lang.org/nomicon/ffi.html">ffi</a></p>
<p>使用c调用固然可以实现稳定的ABI, 我们研究一下在默认的rust调用约定下会发生什么事情.</p>
<p>我们把上面的hello和hi复制出来, 然后修改<code>mylib::num</code>, 使其返回2, 再重新编译, 看看会发生什么</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; cp target/debug/hello .
</span><span>&gt; cp target/debug/hi .
</span><span>&gt; cp target/debug/libmylib.so .
</span><span>&gt; ls
</span><span>Cargo.lock  Cargo.toml  hello  hi  libmylib.so  src  target
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:. ./hello
</span><span>Hello, 1 world!
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:. ./hi
</span><span>Hello, 2 world!
</span><span>&gt; RUSTFLAGS=&quot;-C prefer-dynamic -Ctarget-feature=-crt-static&quot; cargo build -v
</span><span>   Compiling mylib v0.1.0 (/tmp/rust/mylib)
</span><span>     Running `rustc --crate-name mylib --edition=2018 /tmp/rust/mylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type dylib --crate-type rlib --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debuginfo=2 -C metadata=b6125a00ae42b63c --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps -C prefer-dynamic -Ctarget-feature=-crt-static`
</span><span>   Compiling hello v0.1.0 (/tmp/rust/hello)
</span><span>     Running `rustc --crate-name hi --edition=2018 src/bin/hi.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=24d23b4e455b3276 -C extra-filename=-24d23b4e455b3276 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib.so --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib.rlib -C prefer-dynamic -Ctarget-feature=-crt-static`
</span><span>     Running `rustc --crate-name hello --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=29d11507098fa904 -C extra-filename=-29d11507098fa904 --out-dir /tmp/rust/hello/target/debug/deps -C incremental=/tmp/rust/hello/target/debug/incremental -L dependency=/tmp/rust/hello/target/debug/deps --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib.so --extern mylib=/tmp/rust/hello/target/debug/deps/libmylib.rlib -C prefer-dynamic -Ctarget-feature=-crt-static`
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.33s
</span><span>&gt; exa -T target --ignore-glob incremental
</span><span>target
</span><span>├── CACHEDIR.TAG
</span><span>└── debug
</span><span>   ├── build
</span><span>   ├── deps
</span><span>   │  ├── hello-29d11507098fa904
</span><span>   │  ├── hello-29d11507098fa904.d
</span><span>   │  ├── hi-24d23b4e455b3276
</span><span>   │  ├── hi-24d23b4e455b3276.d
</span><span>   │  ├── libmylib.rlib
</span><span>   │  ├── libmylib.so
</span><span>   │  └── mylib.d
</span><span>   ├── examples
</span><span>   ├── hello
</span><span>   ├── hello.d
</span><span>   ├── hi
</span><span>   ├── hi.d
</span><span>   └── libmylib.so
</span></code></pre>
<p>注意到这3个crate都重编译了, 我们现在有两份它们的产物, 看看它们的运行结果是什么.</p>
<p>旧libmylib.so+旧程序的结果:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:. ./hello
</span><span>Hello, 1 world!
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:. ./hi
</span><span>Hello, 2 world!
</span></code></pre>
<p>旧libmylib.so+新程序, 结果和旧libmylib.so+旧程序一样</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:. ./target/debug/hello
</span><span>Hello, 1 world!
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:. ./target/debug/hi
</span><span>Hello, 2 world!
</span></code></pre>
<p>新libmylib.so+新程序的结果:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug ./target/debug/hello
</span><span>Hello, 2 world!
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug ./target/debug/hi
</span><span>Hello, 4 world!
</span></code></pre>
<p>新libmylib.so+旧程序, 结果和新libmylib.so+新程序一样</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug ./hello
</span><span>Hello, 2 world!
</span><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug ./hi
</span><span>Hello, 4 world!
</span></code></pre>
<p>可见这个修改的确没有改变libmylib.so的ABI.</p>
<p>此时我们将<code>mylib</code>的版本号升为0.11, 重新编译, 并运行新libmylib.so+旧程序的组合:</p>
<pre data-lang="output" style="background-color:#fdf6e3;color:#657b83;" class="language-output "><code class="language-output" data-lang="output"><span>&gt; LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-musl/lib/rustlib/x86_64-unknown-linux-musl/lib:./target/debug ./hi
</span><span>Error relocating ./hi: _ZN5mylib3num17hefef8e0aa2fb2876E: symbol not found
</span><span>&gt; nm ./hi | grep U
</span><span>                 U _Unwind_Resume
</span><span>                 U _ZN3std2io5stdio6_print17h1ded803b1aed6cccE
</span><span>                 U _ZN3std2rt19lang_start_internal17h6606fb5e766e2b1cE
</span><span>                 U _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h05aa13cbe62062a9E
</span><span>                 U _ZN4core9panicking5panic17h1c3c966b042834b6E
</span><span>                 U _ZN5mylib3num17hefef8e0aa2fb2876E
</span><span>                 U __libc_start_main
</span><span>                 U rust_eh_personality
</span><span>&gt; nm target/debug/libmylib.so
</span><span>0000000000002640 d _DYNAMIC
</span><span>00000000000015e0 T _ZN5mylib3num17hcb5835737be2d5afE
</span><span>00000000000004e0 r __EH_FRAME_LIST_END__
</span><span>                 w __cxa_finalize
</span><span>                 w __deregister_frame_info
</span><span>00000000000037f8 d __dso_handle
</span><span>                 w __register_frame_info
</span><span>0000000000000498 r __rustc_debug_gdb_scripts_section__
</span><span>00000000000015eb t _fini
</span><span>00000000000015e8 t _init
</span><span>0000000000000000 N rust_metadata_mylib_1bbf50884b077dacedc7265861b262ff
</span></code></pre>
<p>注意到libmylib.so符号名后面的hash发生了变化, 这导致elf无法找到原有的符号.实际上, 这个hash是rust实现单crate多版本共存的重要机制, 被称为SVH (strict version hash), 是整个crate计算得出的hash结果. SVH的计算过程是高度不稳定的rustc内部细节, 我们只能假设当任何crate的依赖, 元数据(例如名称和版本号), 源代码(例如文件名和代码的HIR)发生变化时, SVH就会发生变化, 引起重新编译. 同一crate的不同版本计算可以得到不同的SVH,因此rust允许同时使用同一crate的不同版本, 除非该crate包含了<code>#[no_mangle]</code>修饰的符号.</p>
<p>但是SVH限制了我们在动态编译时升级版本的能力.由于版本号的变化, SVH会发生变化, 因此我们在升级动态链接的dylib依赖的版本时也必须重编译所有依赖它的程序.虽然rust使用semver标识向前兼容性, 但是rustc显然不信任人类手动标识的版本号, 而是一刀切的认为所有版本号的变化都是breaking change.而且这也包括rustc本身版本号的变化, 在升级rustc后, 即使是隔着一天的nightly, 所有先前编译的二进制文件都会失效.</p>
<p>到目前为止, 唯一可行的方法就是使用cdylib, 将API都导出为C接口, 这样就可以做到不需要重编译的升级库版本了.目前gtk的依赖, 解析并渲染SVG矢量图的库librsvg就是一个rust编写并导出C API的库, 其维护者使用rust的生态重写了librsvg, 并使其C API和ABI没有变化. 但是纯rust生态下, rustc还没有相关的机制或方法实现类似的效果, 我们必须在将动态库和程序一一绑定.</p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://12101111.github.io/tags/rust/">#Rust</a>
                    
                        <a href="https://12101111.github.io/tags/linux/">#Linux</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;12101111.github.io&#x2F;rust-no-main&#x2F;">‹ 什么, 你不喜欢main函数?</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;12101111.github.io&#x2F;block-wine-wechat-black-window&#x2F;">屏蔽微信在Wine中运行时产生的水印&#x2F;黑块（Linux Edition） ›</a>
                    
                    
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://12101111.github.io/even.js" ></script>
      
    </body>

</html>
