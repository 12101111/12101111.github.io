<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>12101111&#x27;s blog - lld为什么在多核CPU上这么慢</title>

      
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://12101111.github.io/rss.xml">
      

      
    <script src="https://12101111.github.io/slideout.min.js"></script>


      
          <link rel="stylesheet" href="https://12101111.github.io/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Coding...</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;12101111.github.io">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;12101111.github.io">Coding...</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;12101111.github.io">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/#perf-top" class="toc-link">perf top</a>
                    
                </li>
                
                <li>
                    <a href="https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/#shi-yong-jemallocti-dai-muslde-mallocng" class="toc-link">使用jemalloc替代musl的mallocng</a>
                    
                </li>
                
                <li>
                    <a href="https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/#perf-record" class="toc-link">perf record</a>
                    
                </li>
                
                <li>
                    <a href="https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/#suo-yi-wei-shi-yao-lldzhe-li-zhe-yao-man" class="toc-link">所以为什么lld这里这么慢</a>
                    
                </li>
                
                <li>
                    <a href="https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/#fix" class="toc-link">Fix</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;12101111.github.io&#x2F;lld-cpu-high-usage-on-spin-lock&#x2F;">lld为什么在多核CPU上这么慢</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-08-04</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>最近在一台48核96线程的服务器上编译chromium, 使用LLVM12全家桶(Clang, lld), 开启了lto, 发现在链接最终的二进制文件chromium时, lld虽然占用了所有的CPU资源, 但是大量CPU占用是发生在内核态的(使用htop可以看到CPU占用条一半以上是红色的), 因此对lld的性能进行了一些分析, 发现了lld为何在在内核态占用大量的CPU资源.</p>
<span id="continue-reading"></span><h2 id="perf-top">perf top</h2>
<p><code>perf top</code> 命令可以显示一个进程各个函数占用CPU的百分比, <code>-p</code>或<code>--pid=</code>可以指定要分析的进程, 不加该参数则表示分析系统所有线程(包括内核线程).</p>
<p>不指定进程pid直接运行<code>perf top</code>,发现最占用CPU的是内核的<code>native_queued_spin_lock_slowpath</code>函数, 位于内核源码的<code>kernel/locking/qspinlock.c</code>文件中.</p>
<p>其余的函数有内核的<code>futex_wake</code>, <code>_raw_spin_lock</code>, <code>futex_wait_setup</code>, libc的<code>__pthread_mutex_lock</code>, <code>__pthread_mutex_timedlock</code>, <code>__pthread_mutex_unlock</code>, <code>malloc</code> <code>memcpy</code>, <code>memcmp</code>, <code>free</code> 等.</p>
<p>通过对内核的挖掘以及perf top提供的信息, 可以得到内核(Linux 5.13)部分的调用栈</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>native_queued_spin_lock_slowpath
</span><span>_raw_spin_lock
</span><span>futex_wake/futex_wait
</span><span>do_futex
</span><span>__x64_sys_futex
</span><span>do_syscall_64
</span><span>entry_SYSCALL_64_after_hwframe
</span></code></pre>
<p>libc(musl libc 1.2.2)的调用栈(注:部分是宏或内联函数)</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>__syscall(SYS_futex,...)
</span><span>__futexwait/__wake
</span><span>__lock/__unlock
</span><span>malloc/free
</span></code></pre>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>__syscall(SYS_futex,...)
</span><span>pthread_mutex_lock/pthread_mutex_timedlock/pthread_mutex_unlock
</span></code></pre>
<h2 id="shi-yong-jemallocti-dai-muslde-mallocng">使用jemalloc替代musl的mallocng</h2>
<p>musl 1.2.0引入的<code>mallocng</code>虽然性能较之前的老<code>malloc</code>实现性能高了不少, 但是查看其源码可知, 在多线程的情况下, 其<code>malloc/free</code>操作仍需要无条件上锁/解锁, 导致多线程场景下的内存分配性能降低. jemalloc是一个著名的高性能<code>malloc</code>库,使用jemalloc替代musl自带的实现可以解决lld因内存大量分配导致的性能下降.</p>
<p>使用该命令使得lld自动使用jemalloc:</p>
<pre data-lang="bash" style="background-color:#fdf6e3;color:#657b83;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#b58900;">sudo</span><span> patchelf</span><span style="color:#268bd2;"> --add-needed</span><span> libjemalloc.so.2 /usr/bin/lld
</span></code></pre>
<h2 id="perf-record">perf record</h2>
<p>替换<code>malloc</code>库后, 仍然有大量的内核自旋锁的调用, 因此需要进一步调查.</p>
<p><code>perf top</code>的动态界面得到的数据并不精确和直观, 可以使用<a href="https://github.com/brendangregg/FlameGraph"><code>FlameGraph</code></a>绘制更加直观的图形</p>
<pre data-lang="bash" style="background-color:#fdf6e3;color:#657b83;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#b58900;">perf</span><span> record</span><span style="color:#268bd2;"> -F</span><span> 200</span><span style="color:#268bd2;"> -p </span><span style="color:#859900;">$</span><span style="color:#268bd2;">PID --call-graph</span><span> lbr
</span><span style="color:#b58900;">perf</span><span> script</span><span style="color:#268bd2;"> -i</span><span> perf.data &gt; out.perf
</span><span style="color:#b58900;">./FlameGraph/stackcollapse-perf.pl</span><span> out.perf &gt; out.folded
</span><span style="color:#b58900;">./FlameGraph/flamegraph.pl</span><span> out.folded &gt; out.svg
</span></code></pre>
<p>最终得到如下的图形</p>
<p><img src="/image/lld.svg" alt="flamegraph" /></p>
<p><a href="/image/lld.svg" target="_blank">flamegraph生成的图片是可交互的，点击此在新标签页打开该svg图片</a></p>
<p>最终我们可以确定llvm内的调用栈为</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/shared_timed_mutex/lock_shared">std::shared_timed_mutex::lock_shared</a>: <a href="https://github.com/llvm/llvm-project/blob/00809c8889ed34a5fe014167aa473216dcb63a47/libcxx/src/shared_mutex.cpp#L61">头文件</a> <a href="https://github.com/llvm/llvm-project/blob/00809c8889ed34a5fe014167aa473216dcb63a47/libcxx/src/shared_mutex.cpp#L61">实现</a></li>
<li><a href="https://llvm.org/doxygen/classllvm_1_1Pass.html#ad729b39eacf070a9bca84533b3c743bf">llvm::Pass::getPassName</a>: <a href="https://github.com/llvm/llvm-project/blob/39fa96a4906934774ba20bcb0cd5f808f619f3a6/llvm/include/llvm/Pass.h#L107">头文件</a> <a href="https://github.com/llvm/llvm-project/blob/39fa96a4906934774ba20bcb0cd5f808f619f3a6/llvm/lib/IR/Pass.cpp#L76">实现</a></li>
<li><a href="https://llvm.org/doxygen/classllvm_1_1FPPassManager.html#a0dec4e6b40dec12d8c6a17040ee73021">llvm::FPPassManager::runOnFunction</a>: <a href="https://github.com/llvm/llvm-project/blob/46020f6f0c8aa134002208b2ecf0593b04c46d08/llvm/lib/IR/LegacyPassManager.cpp#L1402">实现</a></li>
</ul>
<h2 id="suo-yi-wei-shi-yao-lldzhe-li-zhe-yao-man">所以为什么lld这里这么慢</h2>
<p>在<code>llvm::FPPassManager::runOnFunction</code>中, 只有这一行调用了<code>getPassName()</code></p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>llvm::TimeTraceScope </span><span style="color:#b58900;">PassScope</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">RunPass</span><span style="color:#839496;">&quot;</span><span>, FP-&gt;</span><span style="color:#b58900;">getPassName</span><span>());
</span></code></pre>
<p>根据<a href="https://llvm.org/doxygen/structllvm_1_1TimeTraceScope.html"><code>llvm::TimeTraceScope</code>的文档</a>, The <a href="https://llvm.org/doxygen/structllvm_1_1TimeTraceScope.html">TimeTraceScope</a> is a helper class to call the begin and end functions of the time trace profiler. When the object is constructed, it begins the section; and when it is destroyed, it stops it. If the time profiler is not initialized, the overhead is a single branch.</p>
<p>虽然这个class的overhead很小, 但是为了计算它的构造函数的参数, overhead很大, 而且这个参数的内容在profiler没有启用时直接就扔掉了. 显然这里应该使用一个闭包或者别的进行lazy evaluation.</p>
<p>继续挖掘为什么<code>getPassName()</code>会用到锁.</p>
<p><code>llvm::Pass</code>这个类的子类大多重写了<code>getPassName()</code>方法, 例如:</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>  StringRef </span><span style="color:#b58900;">getPassName</span><span>() </span><span style="color:#859900;">const override </span><span>{ </span><span style="color:#859900;">return </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Loop Pass Manager</span><span style="color:#839496;">&quot;</span><span>; }
</span></code></pre>
<p>但是没有重写的子类就会使用默认的实现:</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>StringRef Pass::</span><span style="color:#b58900;">getPassName</span><span>() </span><span style="color:#859900;">const </span><span>{
</span><span>  AnalysisID AID =  </span><span style="color:#b58900;">getPassID</span><span>();
</span><span>  </span><span style="color:#859900;">const</span><span> PassInfo </span><span style="color:#859900;">*</span><span>PI = PassRegistry::</span><span style="color:#b58900;">getPassRegistry</span><span>()-&gt;</span><span style="color:#b58900;">getPassInfo</span><span>(AID);
</span><span>  </span><span style="color:#859900;">if </span><span>(PI)
</span><span>    </span><span style="color:#859900;">return</span><span> PI-&gt;</span><span style="color:#b58900;">getPassName</span><span>();
</span><span>  </span><span style="color:#859900;">return </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Unnamed pass: implement Pass::getPassName()</span><span style="color:#839496;">&quot;</span><span>;
</span><span>}
</span></code></pre>
<p>注意到这里的<code>PassRegistry::getPassRegistry()</code>调用, 其<a href="https://github.com/llvm/llvm-project/blob/39fa96a4906934774ba20bcb0cd5f808f619f3a6/llvm/lib/IR/PassRegistry.cpp#L30">代码</a>为:</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#859900;">static</span><span> ManagedStatic&lt;PassRegistry&gt; PassRegistryObj;
</span><span>PassRegistry </span><span style="color:#859900;">*</span><span>PassRegistry::</span><span style="color:#b58900;">getPassRegistry</span><span>() {
</span><span>  </span><span style="color:#859900;">return &amp;*</span><span>PassRegistryObj;
</span><span>}
</span></code></pre>
<p>PassRegistry是一个加了锁的全局变量, 其<a href="https://github.com/llvm/llvm-project/blob/39fa96a4906934774ba20bcb0cd5f808f619f3a6/llvm/include/llvm/PassRegistry.h#L38">定义</a>为:</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#93a1a1;">/// PassRegistry - This class manages the registration and intitialization of
</span><span style="color:#93a1a1;">/// the pass subsystem as application startup, and assists the PassManager
</span><span style="color:#93a1a1;">/// in resolving pass dependencies.
</span><span style="color:#93a1a1;">/// NOTE: PassRegistry is NOT thread-safe.  If you want to use LLVM on multiple
</span><span style="color:#93a1a1;">/// threads simultaneously, you will need to use a separate PassRegistry on
</span><span style="color:#93a1a1;">/// each thread.
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">PassRegistry </span><span>{
</span><span>  </span><span style="color:#859900;">mutable</span><span> sys::SmartRWMutex&lt;</span><span style="color:#b58900;">true</span><span>&gt; Lock;
</span><span>
</span><span>  </span><span style="color:#93a1a1;">/// PassInfoMap - Keep track of the PassInfo object for each registered pass.
</span><span>  </span><span style="color:#859900;">using </span><span style="color:#b58900;">MapType </span><span>= DenseMap&lt;</span><span style="color:#859900;">const </span><span style="color:#268bd2;">void </span><span style="color:#859900;">*</span><span>, </span><span style="color:#859900;">const</span><span> PassInfo </span><span style="color:#859900;">*</span><span>&gt;;
</span><span>  MapType PassInfoMap;
</span><span>
</span><span>  </span><span style="color:#859900;">using </span><span style="color:#b58900;">StringMapType </span><span>= StringMap&lt;</span><span style="color:#859900;">const</span><span> PassInfo </span><span style="color:#859900;">*</span><span>&gt;;
</span><span>  StringMapType PassInfoStringMap;
</span><span>
</span><span>  std::vector&lt;std::unique_ptr&lt;</span><span style="color:#859900;">const</span><span> PassInfo&gt;&gt; ToFree;
</span><span>  std::vector&lt;PassRegistrationListener </span><span style="color:#859900;">*</span><span>&gt; Listeners;
</span><span>
</span><span style="color:#859900;">public</span><span>:
</span><span>  </span><span style="color:#b58900;">PassRegistry</span><span>() = </span><span style="color:#859900;">default</span><span>;
</span><span>  </span><span style="color:#b58900;">~PassRegistry</span><span>();
</span><span>
</span><span>  </span><span style="color:#93a1a1;">/// getPassRegistry - Access the global registry object, which is
</span><span>  </span><span style="color:#93a1a1;">/// automatically initialized at application launch and destroyed by
</span><span>  </span><span style="color:#93a1a1;">/// llvm_shutdown.
</span><span>  </span><span style="color:#859900;">static</span><span> PassRegistry </span><span style="color:#859900;">*</span><span style="color:#b58900;">getPassRegistry</span><span>();
</span><span>
</span><span>  </span><span style="color:#93a1a1;">/// getPassInfo - Look up a pass&#39; corresponding PassInfo, indexed by the pass&#39;
</span><span>  </span><span style="color:#93a1a1;">/// type identifier (&amp;MyPass::ID).
</span><span>  </span><span style="color:#859900;">const</span><span> PassInfo </span><span style="color:#859900;">*</span><span style="color:#b58900;">getPassInfo</span><span>(</span><span style="color:#859900;">const </span><span style="color:#268bd2;">void </span><span style="color:#859900;">*</span><span style="color:#268bd2;">TI</span><span>) </span><span style="color:#859900;">const</span><span>;
</span><span>
</span><span>  </span><span style="color:#93a1a1;">/// getPassInfo - Look up a pass&#39; corresponding PassInfo, indexed by the pass&#39;
</span><span>  </span><span style="color:#93a1a1;">/// argument string.
</span><span>  </span><span style="color:#859900;">const</span><span> PassInfo </span><span style="color:#859900;">*</span><span style="color:#b58900;">getPassInfo</span><span>(StringRef </span><span style="color:#268bd2;">Arg</span><span>) </span><span style="color:#859900;">const</span><span>;
</span></code></pre>
<p>PassRegistry使用的Map并非线程安全的, 因此使用sys::SmartRWMutex进行保护. 而后面的<code>getPassInfo()</code>则需要加锁解锁的操作:</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#859900;">const</span><span> PassInfo </span><span style="color:#859900;">*</span><span>PassRegistry::</span><span style="color:#b58900;">getPassInfo</span><span>(</span><span style="color:#859900;">const </span><span style="color:#268bd2;">void </span><span style="color:#859900;">*</span><span style="color:#268bd2;">TI</span><span>) </span><span style="color:#859900;">const </span><span>{
</span><span>  sys::SmartScopedReader&lt;</span><span style="color:#b58900;">true</span><span>&gt; </span><span style="color:#b58900;">Guard</span><span>(Lock);
</span><span>  </span><span style="color:#859900;">return</span><span> PassInfoMap.</span><span style="color:#b58900;">lookup</span><span>(TI);
</span><span>}
</span></code></pre>
<p>而<code>SmartRWMutex</code>最终则是对<code>std::shared_timed_mutex</code>以及其他的一些锁的封装.</p>
<h2 id="fix">Fix</h2>
<p>查看<code>llvm::TimeTraceScope</code>的代码, 其构造函数有:</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#93a1a1;">/// The TimeTraceScope is a helper class to call the begin and end functions
</span><span style="color:#93a1a1;">/// of the time trace profiler.  When the object is constructed, it begins
</span><span style="color:#93a1a1;">/// the section; and when it is destroyed, it stops it. If the time profiler
</span><span style="color:#93a1a1;">/// is not initialized, the overhead is a single branch.
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">TimeTraceScope </span><span>{
</span><span>
</span><span>  </span><span style="color:#b58900;">TimeTraceScope</span><span>() = </span><span style="color:#859900;">delete</span><span>;
</span><span>  </span><span style="color:#b58900;">TimeTraceScope</span><span>(</span><span style="color:#859900;">const</span><span> TimeTraceScope </span><span style="color:#859900;">&amp;</span><span>) = </span><span style="color:#859900;">delete</span><span>;
</span><span>  TimeTraceScope </span><span style="color:#859900;">&amp;</span><span style="color:#b58900;">operator=</span><span>(</span><span style="color:#859900;">const</span><span> TimeTraceScope </span><span style="color:#859900;">&amp;</span><span>) = </span><span style="color:#859900;">delete</span><span>;
</span><span>  </span><span style="color:#b58900;">TimeTraceScope</span><span>(TimeTraceScope &amp;&amp;) = </span><span style="color:#859900;">delete</span><span>;
</span><span>  TimeTraceScope </span><span style="color:#859900;">&amp;</span><span style="color:#b58900;">operator=</span><span>(TimeTraceScope &amp;&amp;) = </span><span style="color:#859900;">delete</span><span>;
</span><span>
</span><span>  </span><span style="color:#b58900;">TimeTraceScope</span><span>(StringRef </span><span style="color:#268bd2;">Name</span><span>) {
</span><span>    </span><span style="color:#859900;">if </span><span>(</span><span style="color:#b58900;">getTimeTraceProfilerInstance</span><span>() != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>      </span><span style="color:#b58900;">timeTraceProfilerBegin</span><span>(Name, </span><span style="color:#b58900;">StringRef</span><span>(</span><span style="color:#839496;">&quot;&quot;</span><span>));
</span><span>  }
</span><span>  </span><span style="color:#b58900;">TimeTraceScope</span><span>(StringRef </span><span style="color:#268bd2;">Name</span><span>, StringRef </span><span style="color:#268bd2;">Detail</span><span>) {
</span><span>    </span><span style="color:#859900;">if </span><span>(</span><span style="color:#b58900;">getTimeTraceProfilerInstance</span><span>() != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>      </span><span style="color:#b58900;">timeTraceProfilerBegin</span><span>(Name, Detail);
</span><span>  }
</span><span>  </span><span style="color:#b58900;">TimeTraceScope</span><span>(StringRef </span><span style="color:#268bd2;">Name</span><span>, llvm::function_ref&lt;std::string()&gt; </span><span style="color:#268bd2;">Detail</span><span>) {
</span><span>    </span><span style="color:#859900;">if </span><span>(</span><span style="color:#b58900;">getTimeTraceProfilerInstance</span><span>() != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>      </span><span style="color:#b58900;">timeTraceProfilerBegin</span><span>(Name, Detail);
</span><span>  }
</span><span>  </span><span style="color:#b58900;">~TimeTraceScope</span><span>() {
</span><span>    </span><span style="color:#859900;">if </span><span>(</span><span style="color:#b58900;">getTimeTraceProfilerInstance</span><span>() != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>      </span><span style="color:#b58900;">timeTraceProfilerEnd</span><span>();
</span><span>  }
</span><span>};
</span></code></pre>
<p>显然我们可以在第二个参数Detail的地方传入闭包而不是<code>StringRef</code></p>
<p>进一步查看<code>timeTraceProfilerBegin</code>函数的源码</p>
<pre data-lang="cpp" style="background-color:#fdf6e3;color:#657b83;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">struct </span><span>llvm::</span><span style="color:#b58900;">TimeTraceProfiler </span><span>{
</span><span>  </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">begin</span><span>(std::string </span><span style="color:#268bd2;">Name</span><span>, llvm::function_ref&lt;std::string()&gt; </span><span style="color:#268bd2;">Detail</span><span>) {
</span><span>    Stack.</span><span style="color:#b58900;">emplace_back</span><span>(steady_clock::</span><span style="color:#b58900;">now</span><span>(), </span><span style="color:#b58900;">TimePointType</span><span>(), std::</span><span style="color:#b58900;">move</span><span>(Name),
</span><span>                       </span><span style="color:#b58900;">Detail</span><span>());
</span><span>  }
</span><span>}
</span><span>
</span><span style="color:#268bd2;">void </span><span>llvm::</span><span style="color:#b58900;">timeTraceProfilerBegin</span><span>(StringRef </span><span style="color:#268bd2;">Name</span><span>, StringRef </span><span style="color:#268bd2;">Detail</span><span>) {
</span><span>  </span><span style="color:#859900;">if </span><span>(TimeTraceProfilerInstance != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>    TimeTraceProfilerInstance-&gt;</span><span style="color:#b58900;">begin</span><span>(std::</span><span style="color:#b58900;">string</span><span>(Name),
</span><span>                                     </span><span style="color:#268bd2;">[</span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">]</span><span>() { </span><span style="color:#859900;">return </span><span>std::</span><span style="color:#b58900;">string</span><span>(Detail); });
</span><span>}
</span><span>
</span><span style="color:#268bd2;">void </span><span>llvm::</span><span style="color:#b58900;">timeTraceProfilerBegin</span><span>(StringRef </span><span style="color:#268bd2;">Name</span><span>,
</span><span>                                  llvm::function_ref&lt;std::string()&gt; </span><span style="color:#268bd2;">Detail</span><span>) {
</span><span>  </span><span style="color:#859900;">if </span><span>(TimeTraceProfilerInstance != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>    TimeTraceProfilerInstance-&gt;</span><span style="color:#b58900;">begin</span><span>(std::</span><span style="color:#b58900;">string</span><span>(Name), Detail);
</span><span>}
</span><span>
</span><span style="color:#268bd2;">void </span><span>llvm::</span><span style="color:#b58900;">timeTraceProfilerEnd</span><span>() {
</span><span>  </span><span style="color:#859900;">if </span><span>(TimeTraceProfilerInstance != </span><span style="color:#b58900;">nullptr</span><span>)
</span><span>    TimeTraceProfilerInstance-&gt;</span><span style="color:#b58900;">end</span><span>();
</span><span>}
</span></code></pre>
<p>显然传入<code>StringRef</code>也会立刻复制一遍然后放进闭包里, 所以修复方案就是直接把所有<code>TimeTraceScope</code>的构造换成传入闭包的形式, 这样不使用llvm自身的profiler时就不需要计算这个string了.</p>
<p>在替换了所有的函数调用为闭包之后(<a href="https://github.com/12101111/overlay/blob/master/sys-devel/llvm/files/no-lock.patch">点此查看补丁文件</a>), lld的性能提升明显, 链接时间从数十个CPU小时降低为1个CPU小时,修复后的火焰图如下:</p>
<p><img src="/image/lld2.svg" alt="flamegraph" /></p>
<p><a href="/image/lld2.svg" target="_blank">点击此在新标签页打开该svg图片</a></p>
<p>原有占用大量CPU的锁不见了.</p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://12101111.github.io/tags/gentoo/">#gentoo</a>
                    
                        <a href="https://12101111.github.io/tags/linux/">#Linux</a>
                    
                        <a href="https://12101111.github.io/tags/llvm/">#LLVM</a>
                    
                        <a href="https://12101111.github.io/tags/c/">#C++</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;12101111.github.io&#x2F;xbox-security&#x2F;">‹ Xbox one 的安全措施</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;12101111.github.io&#x2F;llvm-cross-compile&#x2F;">LLVM cross-compiled Linux From Scratch: C &amp; C++ libraries ›</a>
                    
                    
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://12101111.github.io/even.js" ></script>
      
    </body>

</html>
