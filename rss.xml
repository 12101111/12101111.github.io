<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>12101111&#x27;s blog</title>
        <link>https://12101111.github.io</link>
        <description></description>
        <generator>Zola</generator>
        <language>cn</language>
        <atom:link href="https://12101111.github.io/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 10 Nov 2021 00:00:00 +0000</lastBuildDate>
        <item>
            <title>LLVM cross-compiled Linux From Scratch: Bootable kernel and initramfs</title>
            <pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/llvm-compile-kernel-initramfs/</link>
            <guid>https://12101111.github.io/llvm-compile-kernel-initramfs/</guid>
            <description>&lt;p&gt;本文章是LLVM编译Linux系统的第二篇文章,介绍如何使用LLVM&#x2F;Clang&#x2F;musl工具链编译一个可以启动的Linux内核.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>LLVM cross-compiled Linux From Scratch: C &amp; C++ libraries</title>
            <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/llvm-cross-compile/</link>
            <guid>https://12101111.github.io/llvm-cross-compile/</guid>
            <description>&lt;p&gt;本系列文章将介绍如何使用LLVM工具链组装一个可用的Linux发行版. 本文已经更新以适应LLVM 13发生的一些变化.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mian-xiang-du-zhe&quot;&gt;面向读者&lt;&#x2F;h2&gt;
&lt;p&gt;本文假定读者可以熟练的使用Unix-like系统,具有一定的C&#x2F;C++编程能力,具有编译开源软件的经验.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yao-shi-gong-ju-lian&quot;&gt;什么是工具链&lt;&#x2F;h2&gt;
&lt;p&gt;工具链,即一套具有工作顺序,可以编译出软件的工具.某些教科书上讲的&amp;quot;编译-&amp;gt;汇编-&amp;gt;链接&amp;quot;这一过程就粗略的描述了工具链的工作过程.&lt;&#x2F;p&gt;
&lt;p&gt;广义上讲,工具链除了编译期,汇编器,链接器还包含一些所有程序都会使用的库.&lt;&#x2F;p&gt;
&lt;p&gt;GNU工具链和LLVM工具链的对比:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;项目&lt;&#x2F;th&gt;&lt;th&gt;GNU工具链&lt;&#x2F;th&gt;&lt;th&gt;LLVM工具链&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;C 编译器&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;gcc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;clang&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;C++编译器&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;g++&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;clang++&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;binutils&lt;&#x2F;td&gt;&lt;td&gt;GNU binutils&lt;&#x2F;td&gt;&lt;td&gt;LLVM binutils&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;汇编器&lt;&#x2F;td&gt;&lt;td&gt;GNU &lt;code&gt;as&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;集成汇编器&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;链接器&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;ld.bfd&lt;&#x2F;code&gt;, &lt;code&gt;ld.gold&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;LLVM linker &lt;code&gt;ld.lld&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;运行时(intrinsics)&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;libgcc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;compiler-rt&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;原子操作&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;libatomic&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;compiler-rt&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;C 语言库&lt;&#x2F;td&gt;&lt;td&gt;GNU libc &lt;code&gt;glibc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;LLVM libc&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;C++ 标准库&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;libstdc++&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;libc++&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;C++ ABI&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;Libsupcxx&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;libc++abi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;栈展开(unwind)&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;libgcc_s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;LLVM &lt;code&gt;libunwind&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</description>
        </item>
        <item>
            <title>lld为什么在多核CPU上这么慢</title>
            <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/</link>
            <guid>https://12101111.github.io/lld-cpu-high-usage-on-spin-lock/</guid>
            <description>&lt;p&gt;最近在一台48核96线程的服务器上编译chromium, 使用LLVM12全家桶(Clang, lld), 开启了lto, 发现在链接最终的二进制文件chromium时, lld虽然占用了所有的CPU资源, 但是大量CPU占用是发生在内核态的(使用htop可以看到CPU占用条一半以上是红色的), 因此对lld的性能进行了一些分析, 发现了lld为何在在内核态占用大量的CPU资源.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Xbox one 的安全措施</title>
            <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/xbox-security/</link>
            <guid>https://12101111.github.io/xbox-security/</guid>
            <description>&lt;p&gt;本文将翻译Xbox Live团队Xbox One安全系统架构师Tony Chen在2019年平台安全峰会(Platform Security Summit 2019, PSEC 2019)上的演讲&lt;&#x2F;p&gt;
&lt;p&gt;PSEC 2019官方页面, 内附演讲视频: &lt;a href=&quot;https:&#x2F;&#x2F;www.platformsecuritysummit.com&#x2F;2019&#x2F;speaker&#x2F;chen&#x2F;&quot;&gt;抵御物理攻击, Xbox one的故事(Guarding Against Physical Attacks: The Xbox One Story)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Using sccache on gentoo</title>
            <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/using-sccache-on-gentoo/</link>
            <guid>https://12101111.github.io/using-sccache-on-gentoo/</guid>
            <description>&lt;p&gt;Firest please fellow the page of &lt;a href=&quot;https:&#x2F;&#x2F;wiki.gentoo.org&#x2F;wiki&#x2F;Sccache&quot;&gt;Sccache&lt;&#x2F;a&gt; on Gentoo wiki.&lt;&#x2F;p&gt;
&lt;p&gt;After the installation and configuration of sccache, you can try to compile some rust packages.
It may work fine for the first one, but later you may find some weird sandbox or permission error like &amp;quot;sccache: error : Failed to create temp dir ...&amp;quot; or &amp;quot;sccache: caused by: Permission denied (os error 13)&amp;quot;&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s fix this issue.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>屏蔽微信在Wine中运行时产生的水印&#x2F;黑块（Linux Edition）</title>
            <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/block-wine-wechat-black-window/</link>
            <guid>https://12101111.github.io/block-wine-wechat-black-window/</guid>
            <description>&lt;p&gt;众所周知，微信并没有官方开发的Linux客户端，要想在Linux上使用微信，就产生了很多种变通方法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;网页版&lt;&#x2F;li&gt;
&lt;li&gt;Wine+微信 PC版&lt;&#x2F;li&gt;
&lt;li&gt;虚拟机+微信 PC版&lt;&#x2F;li&gt;
&lt;li&gt;Android虚拟机&#x2F;容器+微信平板模式&lt;&#x2F;li&gt;
&lt;li&gt;在其他设备上使用，并使用RDP&#x2F;scrcpy等软件远程控制&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在这些解决方案中，微信 PC版在操作逻辑和功能上较其他方案更强，但是由于微信 win32程序会创建一个独立的半透明的窗口作为其窗口边框和UI控件的阴影特效，而在Linux下，Wine会将这个透明的窗口错误的绘制，产生一些奇怪的bug， 例如这个透明边框总是悬浮在所有窗口的最上面，即使已经切换到其他的工作区，或者由于Xwayland的背景是黑色的，这个半透明的窗口会继承黑色的背景，导致其效果不再是一个阴影框，而是一个覆盖整个窗口的黑色块。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust动态链接</title>
            <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/rust-dynamic-link/</link>
            <guid>https://12101111.github.io/rust-dynamic-link/</guid>
            <description>&lt;p&gt;本文探讨一下Rust的crate类型的概念, 以及如何在Rust中使用动态链接编译动态库. 同时对比rust编译出的动态库和使用C语言接口动态库, 看看rust动态库是否能实现C语言接口动态库的功能.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>什么, 你不喜欢main函数?</title>
            <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/rust-no-main/</link>
            <guid>https://12101111.github.io/rust-no-main/</guid>
            <description>&lt;p&gt;要想编译一个rust的可执行程序, 必须在crate顶层定义&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;crates-and-source-files.html#main-functions&quot;&gt;&lt;code&gt;main&lt;&#x2F;code&gt;函数&lt;&#x2F;a&gt;. &lt;code&gt;main&lt;&#x2F;code&gt;函数没有参数, 没有trait或生命周期修饰, 返回值为&lt;code&gt;()&lt;&#x2F;code&gt;(或者不写返回值类型), &lt;code&gt;!&lt;&#x2F;code&gt;, &lt;code&gt;Result&amp;lt;(), E&amp;gt; where E: Error&lt;&#x2F;code&gt;或其他实现&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;process&#x2F;trait.Termination.html&quot;&gt;std::process::Termination&lt;&#x2F;a&gt; Trait的类型.&lt;&#x2F;p&gt;
&lt;p&gt;虽然大多数情况下rust的用户只需要老实的写一个&lt;code&gt;main&lt;&#x2F;code&gt;函数就能让他们的程序跑起来了,但是总有一些奇怪的情况使得&lt;code&gt;bin&lt;&#x2F;code&gt;类型的crate没有rust要求的&lt;code&gt;main&lt;&#x2F;code&gt;函数`.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>庆祝OpenBSD 25周年与OpenBSD 6.8, NetBSD 9.1, FreeBSD 12.2发布, 有关Unix,BSD与Linux的看法</title>
            <pubDate>Sun, 18 Oct 2020 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/linux-bsd-comparison/</link>
            <guid>https://12101111.github.io/linux-bsd-comparison/</guid>
            <description>&lt;h1 id=&quot;linuxhe-bsdyou-shi-yao-qu-bie&quot;&gt;Linux和BSD有什么区别&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;li-shi&quot;&gt;历史&lt;&#x2F;h2&gt;
&lt;p&gt;Unix源自贝尔实验室计算科学研究中心(CSRC)即贝尔实验室1127部门, Ken Thompson和Dennis Ritchie先后创造了Unix操作系统和C语言.尽管Unix最早运行在PDP-7和PDP11小型机上, 但是C语言的可移植性使得Unix移植到其他机器上也很容易.&lt;&#x2F;p&gt;
&lt;p&gt;贝尔实验室一共发布了10个版本的Unix, 也叫&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Research_Unix&quot;&gt;Research Unix&lt;&#x2F;a&gt;, 年代从1971年11月的第一版至1989年10月的第十版.其中版本号是根据用户手册(即&lt;code&gt;man&lt;&#x2F;code&gt;命令)描述的.第一版到第三版是汇编写的,第4版(1973年11月)用C语言重写了,并且发表在ACM通信杂志上,第5版(1974年6月)被授权给大学等教育机构.&lt;&#x2F;p&gt;
&lt;p&gt;自此开始,AT&amp;amp;T发现了商机,开始销售Unix.Unix第6版(Version 6 UNIX)以$20,000的价格出售(1975年5月, 根据美元的通货膨胀,相对应现在的$95,028),这个价格非常昂贵,但是销售协议并不禁止源代码用于教学,新南威尔士大学的John Lions教授出版了Lions对Unix第六版的注释,带源代码(Lions&#x27; Commentary on UNIX 6th Edition, with Source Code), 成为贝尔实验室之外最广泛传播的Unix源代码.Unix第6版不仅销售广泛,而且一些大学和公司将Unix移植到其他机器上, 比如IBM VM&#x2F;370虚拟机,VAX. 个人认为Unix分裂的源泉就是来自Unix v6的授权上, 源码是原样交付的(provide as-is), 在许多移植和开发工作发生后, AT&amp;amp;T并没有有效的组织起用户将修改内容提交到上游,而是自己也销售一个商业分支: PWB&#x2F;UNIX.当然断人财路是AT&amp;amp;T这种垄断公司不能容忍的,Unix第7版(Version 7 UNIX,1979年)的协议阻止了学术用授权在课堂上使用,Lions的书也就禁售了,但是广大师生还是靠着复印继续用这本书.MIT曾经在2002年到2006年教授Unix 6th,直到后来编写了&lt;code&gt;xv6&lt;&#x2F;code&gt;作为Unix在x86上的一个简单的克隆.&lt;&#x2F;p&gt;
&lt;p&gt;之后的Unix第8到第10版基本上就是BSD的修改版,并包括了一些System V的功能.随后CSRC的研究重点转向了九号计划(Plan 9).到了21世纪之后, Research Unix和Plan 9的源代码陆续以自由软件协议开源了,不过也只有研究价值了.&lt;&#x2F;p&gt;
&lt;p&gt;1975年, Ken Thompson作为访问教授来到Berkeley大学,并在这里的PDP-11上安装了Unix v6, 并开始编写一个Pascal编译器.Bill Joy(后来的Sun创始人)为Unix编写了&lt;code&gt;ed&lt;&#x2F;code&gt;编辑器的增强版&lt;code&gt;ex&lt;&#x2F;code&gt;(Extend的缩写), 并改进了Pascal编译器.Bill Joy随后将整个系统和新加入的软件于1978年3月9日发布为&lt;code&gt;Berkeley Software Distribution&lt;&#x2F;code&gt;,即&lt;code&gt;1BSD&lt;&#x2F;code&gt;.Bill Joy又编写了著名的&lt;code&gt;vi&lt;&#x2F;code&gt;,即可视化(visual)的&lt;code&gt;ex&lt;&#x2F;code&gt;(ex是运行在电传打字机上的,vi是运行在视频终端上的),以及C shell(&lt;code&gt;csh&lt;&#x2F;code&gt;).这些改进被发布为&lt;code&gt;2BSD&lt;&#x2F;code&gt;.随后Berkeley购买了32位的VAX计算机,因为当时Unix的VAX移植没有利用VAX的虚拟内存功能,Berkeley的学生重写了Unix的内核,并将软件移植到了新内核上.这些被作为&lt;code&gt;3BSD&lt;&#x2F;code&gt;于1979年发布.&lt;code&gt;4BSD&lt;&#x2F;code&gt;于1980年发布,包括了&lt;code&gt;csh&lt;&#x2F;code&gt;的任务控制和Curses终端UI(TUI)库.Bill Joy大幅度改进了BSD内核在VAX上的性能,并作为&lt;code&gt;4.1BSD&lt;&#x2F;code&gt;于1981年发布.Bill Joy在1982年加入了刚成了的Sun Microsystems, 并开发了在68000上运行的BSD系统.&lt;&#x2F;p&gt;
&lt;p&gt;1978年,微软从AT&amp;amp;T手中购买了UNIX v7的授权,然后以XENIX的名字再卖给OEM(例如IBM和Intel).XENIX移植到了Z8001,68000以及当时流行的IBM PC.由于16位的IBM PC和其他家用计算机相较于大型机&#x2F;小型机更加便宜,因此XENIX是当时销售最广的UNIX变种.然而后来微软更重视和IBM合作开发的OS&#x2F;2系统,以及新的Windows NT系统,在1987年将XENIX卖给了SCO.&lt;&#x2F;p&gt;
&lt;p&gt;到了80年代, AT&amp;amp;T继续推进UNIX的商业化.1982年, AT&amp;amp;T在UNIX v7的基础上开发了UNIX System III, 并以$100(现在的$281.22)的价格出售,只能在PDP-11和VAX上运行.随后,AT&amp;amp;T整合了当时各个UNIX分支的功能,例如BSD的vi, 于1983年发布了UNIX System V Release1 (SVR1).然而同年,AT&amp;amp;T因为输了与美国司法部的反垄断官司,被拆分为7个小贝尔公司,负责各地的电话业务,以及AT&amp;amp;T公司从事长途电话业务和通信设备制造业务.同样是这年9月27日, 因为在大学中看不到UNIX源码的Richard Stallman决定从头开发一个&lt;strong&gt;自由&lt;&#x2F;strong&gt;的UNIX操作系统的替代品.System V的著名功能包括SysV IPC和SysV &lt;code&gt;init.d&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;由于各个UNIX差异越来越大, IEEE觉得标准化UNIX的API和命令行接口, 该标准被称为POSIX (Portable Operating System Interface).第一版于1988年发布(IEEE 1003.1-1988).&lt;&#x2F;p&gt;
&lt;p&gt;1987年,Andrew S. Tanenbaum教授为了教授操作系统课程,编写了Operating Systems: Design and Implementation教材,并在其中发行了Minix, 一个微内核操作系统. Minix 运行在16位的IBM PC&#x2F;AT计算机上,可以安装到软盘,仅包括12,000行代码.尽管Minix代码可用,但是其必须和教材一起出售($69),因此不能自由分发.这限制了Minix在90年代的进一步发展.&lt;&#x2F;p&gt;
&lt;p&gt;但当时UNIX的许多重要的新功能实际上来自于BSD.尤其是1983年的&lt;code&gt;4.2BSD&lt;&#x2F;code&gt;包括了TCP&#x2F;IP的实现.
4.3BSD(1986)改进了TCP&#x2F;IP的实现,4.3BSD-Tahoe(1988)提升了代码的可移植性,并包含了著名的TCP拥塞控制算法Tahoe.由于AT&amp;amp;T的协议不允许源代码分发, BSD中的AT&amp;amp;T代码被移除, 并以BSD协议发布, 称之为Networking Release 1 (Net&#x2F;1).4.3BSD-Reno(1990)则包括了对Tahoe算法的修改,Reno则成为最基本的TCP拥塞控制算法.&lt;&#x2F;p&gt;
&lt;p&gt;而AT&amp;amp;T于1988年发布了UNIX System V Release 4.0 (SVR4), 并整合了4.3BSD, Xenix, SunOS的功能.许多商业UNIX都迁移到SVR4上,这包括流传至今的IBM AIX, HP的HP-UX和Sun&#x2F;Oracle的Solaris(即SunOS).
SVR4是AT&amp;amp;T发布的最后一个Unix, 1992年AT&amp;amp;T将Unix卖给了Novell,随后又卖给了Xenix的开发商SCO. 逐利的资本家在1996年将AT&amp;amp;T拆分出了朗讯,Bell实验室也被划分走.
流传至今的唯一的开源System V后代即Oracle收购Sun前的Solaris 10 (OpenSolaris),以及Fork出的illumos.&lt;&#x2F;p&gt;
&lt;p&gt;Net&#x2F;1发布之后, BSD开发者 Keith Bostic(也是后来的Berkeley DB开发者)认为应该继续重写AT&amp;amp;T的代码, 1991年6月, Net&#x2F;2发布. 一些BSD开发者成立了Berkeley Software Design Inc.(BSDi)公司继续开发Net&#x2F;2并将其移植到Intel 80386,被称为BSD&#x2F;OS (BSD&#x2F;386).另一些BSD开发者则继续以BSD协议移植Net&#x2F;2到80386, 称之为386BSD项目.&lt;&#x2F;p&gt;
&lt;p&gt;由于Net&#x2F;2删掉了一些代码,因此并不完整, 1992年7月,386BSD发布可用的0.1版本.由于386BSD的开发缓慢, 一些386BSD的开发者继续开发工作,成立了FreeBSD项目.由于意见不合,另一些386BSD开发者成立了NetBSD项目.&lt;&#x2F;p&gt;
&lt;p&gt;BSDi以$995销售BSD&#x2F;386的源码,远比AT&amp;amp;T便宜, 这招来了AT&amp;amp;T的官司.1993年, &lt;code&gt;4.4BSD-Encumbered&lt;&#x2F;code&gt;发布,并且需要Unix的商业协议.在Unix被卖给Novell后,在Berkeley大学的支持下,双方于1994年和解.1994年3月,4.4BSD-Lite发布,其进行了进一步的修改不包括非BSD的代码.BSDi和Novell的和解细节不得而知,但是公开信息表明BSDi需要将其系统迁移至&lt;code&gt;4.4BSD-Lite&lt;&#x2F;code&gt;.最后一个从Berkeley发布的BSD是&lt;code&gt;4.4BSD-Lite Release 2&lt;&#x2F;code&gt;,随后Berkeley的CSRG解散.&lt;&#x2F;p&gt;
&lt;p&gt;BSDi于2001年出售了其操作系统业务给Wind River Systems, 其服务器业务则整合为iXsystems Inc.iXsystems于2006年收购了PC-BSD项目,并开发了FreeNAS系统.2009年, 一部分FreeNAS开发者决定转移至Debian Linux并开发了OpenMediaVault.&lt;&#x2F;p&gt;
&lt;p&gt;虽然未被指控,但FreeBSD 1.0包含了4.3BSD的代码,因此1994年11月发布的FreeBSD 2.0迁移到&lt;code&gt;4.4BSD-Lite&lt;&#x2F;code&gt;.FreeBSD现在并不提供FreeBSD 1.0的下载.NetBSD 1.0也迁移至&lt;code&gt;4.4BSD-Lite&lt;&#x2F;code&gt;.1995年, 由于意见不合, NetBSD创始人之一Theo de Raadt fork了NetBSD并成立OpenBSD组织.&lt;&#x2F;p&gt;
&lt;p&gt;1991年, 大学生Linus Torvalds刚刚购买了新计算机, 具有80386CPU, 却发现只能用单用户的DOS操作系统.而当时的Minix系统为16位8088设计,没有利用上80386强大的32位处理能力以及mmu.而此时386BSD的移植工作正在进行, 并没有发布可用的版本.GNU工程的Hurd内核则开发进度缓慢,功能很不完整.剩余的商用UNIX则极其昂贵.由于没有可用的,自由的内核可以利用386的功能,Linus Torvalds按照Intel开发者手册和Operating Systems: Design and Implementation教材自己开发新的内核.开发工作是在MINIX系统上进行的,并使用了GNU工程的gcc和bash等软件.Torvalds于1991年8月宣布了开发这个内核的消息,并于10月发布0.0.1版.第一个版本功能很不完整,包括了6744行C, 2143行C头文件, 1770行汇编和459行makefile.这个内核用于386 AT计算机,需要有VGA显示适配器和IDE硬盘, 此外键盘只支持芬兰键盘,美式键盘会输出错误的字符.Linux 0.0.1使用Minix的文件系统, 可以读取IDE硬盘中的分区,内核可以安装到软盘上.这一年,Linux随后发布了0.0.2,0.03,0.10,0.11, 然而0.0.2和0.0.3的代码现已经丢失. 1992年 1月,Torvalds发布了Linux 0.12, 支持了交换分区, SVGA显卡, Job Control, 虚拟终端, 387浮点协处理器模拟,符号连接, 此时的Linux内核功能已较为完善.下一个版本版本号直接跳到0.95, 然而Torvalds发现了一些bug,因此版本号增加的速度降了下来.0.96成功运行了X服务器,0.97包含了Linux第一个原生文件系统ext, 0.98 包括了TCP&#x2F;IP网络支持.到1993年34月,第一个BSD在386平台的移植NetBSD 0.8发布时(1993年4月19日),经过两年的开发,Linux 0.99.8 (1993年4月9日)已经具有9万2千行代码,包含了一些SCSI硬盘驱动, 支持多种文件系统,支持网络,支持鼠标键盘和X,支持内核压缩存储的成熟内核, 而这一版的NetBSD还包括具有版权问题的文件.而没有版权问题的BSD, NetBSD 1.0于1994年10月发布,FreeBSD 2.0于1994年11月发布, 而Linux 1.0已经于半年前的1994年3月14日发布了,包含了17万6千行代码.&lt;&#x2F;p&gt;
&lt;p&gt;历史没有如果,但是Linus Torvalds本人也表示,如果1991年的时候386BSD已经发布,Linus Torvalds将不会开发Linux, 但BSD由于慢了2年,丢掉了自己的市场.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kernel-vs-os&quot;&gt;Kernel vs OS&lt;&#x2F;h2&gt;
&lt;p&gt;不同于BSD, Linux只是一个内核,而BSD是一个系统.Linux发行版则是GNU&#x2F;Linux特有的概念,其维护了系统可以安装的软件.1993年成立的Debian项目和Redhat公司至今具有巨大的影响力.&lt;&#x2F;p&gt;
&lt;p&gt;Linux发行版和BSD系统的区别就体现在开发和发行这个问题上.Linux发行版将所有的软件,包括内核, libc, shell, Xorg, 浏览器, 游戏都作为软件包,由包管理器管理(apt&#x2F;dpkg,rpm&#x2F;yum&#x2F;dnf,pacman,emerge),而Linux发行版的开发者(打包员)编写打包脚本(control&#x2F;rules, spec, PKGBUILD, ebuild),然后通过构建工具编译软件包,经过测试后上传到软件源.&lt;&#x2F;p&gt;
&lt;p&gt;而BSD首先将软件分为base系统和ports.base系统包括了Unix规范中包括的所有软件,例如内核,shell,编辑器vi,编译器cc,以及这些软件需要的库.base系统中的内核,软件,库都放在同一个源代码管理仓库中.虽然这些软件有很多是来自第三方的,例如几乎所有的BSD都使用Clang和llvm作为工具链,但是llvm的源码被vendor进内核的仓库中.而ports则是所有不包括在base系统中的软件,和Linux发行版一样,具有包管理器(pkg,pkgsrc),而打包脚本的采用BSD make.用户既可以使用包管理器下载二进制软件,也可以直接使用BSD make在对应的目录下运行&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;&#x2F;code&gt;从源码安装软件(就像Archlinux的AUR和Gentoo Linux一样).&lt;&#x2F;p&gt;
&lt;p&gt;另一个区别就是BSD遵循传统,&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;(单用户模式所需文件),&lt;code&gt;&#x2F;usr&lt;&#x2F;code&gt;(多用户模式所需文件),&lt;code&gt;&#x2F;usr&#x2F;X11R6&lt;&#x2F;code&gt;(X窗口系统),&lt;code&gt;&#x2F;usr&#x2F;local&lt;&#x2F;code&gt;(Ports安装的软件和配置文件)具有明确的作用,而Linux所谓的usr merge将&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;和&lt;code&gt;&#x2F;usr&lt;&#x2F;code&gt;合并(因为Systemd并没有单用户模式,且几乎无法不依赖&#x2F;usr),&lt;code&gt;&#x2F;usr&#x2F;local&lt;&#x2F;code&gt;仅用于用户手动编译安装的软件.&lt;&#x2F;p&gt;
&lt;p&gt;BSD对base系统保证其ABI的稳定性,即升级base系统的安全补丁不会导致现有Ports软件需要重新编译或者升级,这同样包括内核ABI的稳定性.而Linux发行版对ABI稳定性则有不同的策略.例如红帽的RHEL保证了内核和系统的ABI稳定性,而ArchLinux则不承诺任何ABI稳定性,甚至阻止部分升级,Gentoo Linux的软件均为手动编译,因此ABI变动时需要重新编译软件包.另一方面,Linux内核的syscall总是稳定的,即升级Linux内核不应该破坏任何软件(除非该软件依赖了不稳定的部分,例如sysfs的输出),但Linux故意的不稳定API和ABI,导致Linux内核模块只能被对应的&lt;em&gt;那一个&lt;&#x2F;em&gt;Linux内核加载.而BSD的内核模块可以被相同大版本号的内核加载(不包括不支持内核模块的OpenBSD).另一方面,当大版本号发生变动时,BSD则不会做出任何ABI稳定性的承诺,因此要小心的从FreeBSD 10.2 升级到 11.1.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;项目&lt;&#x2F;th&gt;&lt;th&gt;Linux&lt;&#x2F;th&gt;&lt;th&gt;BSD&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;协议&lt;&#x2F;td&gt;&lt;td&gt;GPLv2&lt;&#x2F;td&gt;&lt;td&gt;BSD&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;内核&lt;&#x2F;td&gt;&lt;td&gt;独立开发&lt;&#x2F;td&gt;&lt;td&gt;随系统一起开发&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;基本库&#x2F;命令行&lt;&#x2F;td&gt;&lt;td&gt;GNU等组织开发,发行版发行&lt;&#x2F;td&gt;&lt;td&gt;随系统一起开发发行&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;包管理器&lt;&#x2F;td&gt;&lt;td&gt;发行版开发并发布软件源&lt;&#x2F;td&gt;&lt;td&gt;系统更新,Ports,二进制源&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;稳定性&lt;&#x2F;td&gt;&lt;td&gt;内核syscall对用户态稳定,ABI不稳定,用户态随发行版策略&lt;&#x2F;td&gt;&lt;td&gt;base系统大版本内ABI稳定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;gong-neng&quot;&gt;功能&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;drm&quot;&gt;drm&lt;&#x2F;h3&gt;
&lt;p&gt;drm是Linux的显示驱动框架,同等概念的还有Windows NT6&#x2F;10的 WDDM. 近些年X.Org和FreeDesktop.org虽然开发了大量供Unix-like操作系统的桌面软件,但是很多都是Linux专用的.例如Mesa 3D和Xorg使用DRI来和显卡驱动交互,但DRI只能和drm交互,这导致BSD无法使用相关的软件.BSD给出的解决方案是,将Linux的drm模块移植到BSD中,并使用Linux内核兼容接口(例如FreeBSD的linuxkpi)使用drm.虽然amdgpu和i915都是以MIT协议发布drm中的驱动,但是drm本身是GPLv2授权的,因此BSD的移植也是GPLv2授权的.由于是移植自Linux, 因此BSD的显卡驱动支持总是慢于Linux, 并且具有一些Linux没有的bug.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-jian-xi-tong&quot;&gt;文件系统&lt;&#x2F;h3&gt;
&lt;p&gt;Linux支持ExtFS系列, ReiserFS, 来自AIX的JFS, 来自SGI IRIX的XFS, ~~永远不稳定的~~BtrFS,三星给手机开发的F2FS,以及许多小众的文件系统(例如Minixfs), 不支持POSIX的vFAT和来自三星的代码微软的专利的ExtFAT,以及支持用户空间文件系统的FUSE框架.&lt;&#x2F;p&gt;
&lt;p&gt;Ext系列是Linux长期使用的文件系统格式,但是随着ext4的推出,ext系列的可扩展性越来越差(虽然其名称为extended filesystem).2007年, Btrfs原作者, Chris Mason加入当时还没有收购Sun的Oracle公司, 号召社区开发一个新的Linux原生的Cow文件系统.2009年, Btrfs进入Linux主线.Btrfs支持许多有用的文件系统功能,&lt;a href=&quot;https:&#x2F;&#x2F;btrfs.wiki.kernel.org&#x2F;index.php&#x2F;Main_Page#Features&quot;&gt;其wiki上对功能列表进行了记载&lt;&#x2F;a&gt;,大部分功能都是稳定的,有一些功能,例如原生RAID5,具有一些bug,不应该日常使用,&lt;a href=&quot;https:&#x2F;&#x2F;btrfs.wiki.kernel.org&#x2F;index.php&#x2F;Status&quot;&gt;其wiki也记载了功能是否稳定&lt;&#x2F;a&gt;.然而经过10年的开发后,仍有人在升级内核版本后或其他操作后,btrfs发生文件丢失,文件损坏或内核panic.当然这都是小概率事件,BtrFS广泛的在企业环境中使用,因此如果不使用不稳定的功能,通常不会发生文件损坏的事故.&lt;&#x2F;p&gt;
&lt;p&gt;长期以来Unix则使用Unix file system (UFS), 其历史最早追溯到version 7 Unix,但是广泛使用的版本是4.2BSD以及SVR4.由于BSD对该文件系统的代码做出了很多优化,有些系统也将UFS称为Berkeley Fast File System或BSD Fast File System (FFS).现代Unix大多衍生自4.2&#x2F;4.4BSD-Lite和SVR4, 因此许多Unix都支持UFS&#x2F;FFS, 例如Solaris OS, HP-UX, 以及早期的NeXTStep和Mac OS X, 以及衍生自4.2BSD和4.4BSD-lite的386BSD的诸多后代: FreeBSD, OpenBSD, NetBSD, DragonFly BSD.然而随着各个分支的演化, UFS各个实现具有不同的功能,例如FreeBSD 5.x之后包括了UFS 2, NetBSD的FFS从FreeBSD移植了UFS2的功能(NetBSD 5.0), 而直到OpenBSD 6.7发布(2020年4月), OpenBSD才默认使用FFS2.另一方面,FreeBSD的UFS2, NetBSD和Solaris日志使用不同的实现.Linux包含一个UFS的只读驱动,且在挂载时需要指定BSD的变种.&lt;&#x2F;p&gt;
&lt;p&gt;UFS代码虽然久经考验十分稳定,但是功能很少,正如ext4一样.Sun公司开发的Solaris OS也在使用UFS,而为了摆脱UFS的限制,Solaris的开发者Jeff Bonwick,Bill Moore和Matthew Ahrens开始开发Solaris的下一代文件系统和存储管理方案,也就是Z filesystem.Solaris当时作为商业UNIX是一个闭源项目,但是Sun为了吸引用户和开发者不加入Linux阵营, 2005年Sun启动了OpenSolaris项目并以CDDL协议开源了Solaris 10系统的源代码,这也包括正在开发的ZFS代码.2006年,ZFS稳定版作为Solaris 10 U2更新发布. 2006年,ZFS通过FUSE移植到了Linux上.2007年,Apple将ZFS移植到MacOS X上,但Apple于2009年放弃了该项目, MacZFS项目继续该代码的开发.2007年,ZFS移植到FreeBSD并于2008年作为FreeBSD 7的一部分发布.2007年 ZFS也移植到了NetBSD,并于2009年发布.2008年, 原生版本的ZFS到Linux的移植开始开发,被称为ZFS on Linux项目.&lt;&#x2F;p&gt;
&lt;p&gt;有关ZFS的实现细节和与Btrfs的对比可以参见fc老师(farseerfc)的两篇很棒的文章: &lt;a href=&quot;https:&#x2F;&#x2F;farseerfc.me&#x2F;zhs&#x2F;zfs-layered-architecture-design.html&quot;&gt;ZFS 分层架构设计&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;farseerfc.me&#x2F;zhs&#x2F;btrfs-vs-zfs-difference-in-implementing-snapshots.html&quot;&gt;Btrfs vs ZFS 实现 snapshot 的差异&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;而DragonFly BSD则开发了HAMMER文件系统,使用B+树,支持&lt;&#x2F;p&gt;
&lt;p&gt;另一方面,Apple Darwin(包括macOS, iOS, watchOS和tvOS)支持HFS,HFS+和APFS.HFS是一个传统的基于B树的文件系统,HFS+支持了Unicode,可选的日志和大小写敏感功能,ALC,透明压缩(基于Deflate算法),加密功能.令人沮丧的是,HFS+并不支持数据校验!!!Apple意识到HFS+并不是一个21世纪的文件系统,因此设计了APFS(Apple file system),并于2017年发布在iOS 10.3和macOS 10.13 High Sierra上.APFS基于Cow的B树, 面向闪存优化,支持原生全盘加密, 文件克隆(reflink), 瞬时快照,元数据校验和, 透明压缩, 子卷(Volume)空间共享, 基于Cow的数据一致性保护.&lt;&#x2F;p&gt;
&lt;p&gt;既然提到Cow文件系统, Windows server 2012也包括了一个新的文件系统Resilient File System (ReFS), 基于B+树和Cow, 然而Windows不能启动到Refs,且经常随win10的更新发生break change.由于微软并没有公开其资料,因此并没有第三方工具或系统可以挂载Refs.Refs也不支持快照,透明压缩等其他Cow文件系统常见的功能,因此是4种Cow文件系统中最差的一个.&lt;&#x2F;p&gt;
&lt;p&gt;除了FreeBSD和illumos对ZFS具有完整的支持,包括从ZFS启动, NetBSD长期依赖使用一个较老的illumos上的ZFS移植,并于2020年转向FreeBSD的ZFS移植,但仍然不支持从ZFS启动.而OpenBSD认为CDDL过于严格,并不支持ZFS.4大BSD均通过ext2fs驱动支持Linux的ext2-ext4文件系统.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zfsde-zheng-yi&quot;&gt;ZFS的争议&lt;&#x2F;h4&gt;
&lt;p&gt;然而由于商业上的失败,Sun Microsystems于2010年被Oracle收购, Oracle随即终止了OpenSolaris项目,次年发布的Solaris 11成为闭源软件.对此很不满的社区fork了OpenSolaris, 成立illumos继续开发OpenSolaris, 这也包括ZFS. 2013年3月, ZFS on Linux发布首个稳定版, 同时MacZFS项目宣布使用ZFS on Linux的代码.随后的2013年9月,OpenZFS项目成立,致力于整合illumos, Linux, FreeBSD和macOS上的开源ZFS实现, Matt Ahrens等开发者继续独立于Oracle开发开源ZFS. 2020年, 基于ZFS on Linux代码的OpenZFS 2.0发布, ZFS on Linux和FreeBSD 13.0首次采用了同一份代码.&lt;&#x2F;p&gt;
&lt;p&gt;然而Sun当初开源OpenSolaris&lt;em&gt;可能&lt;&#x2F;em&gt;有意的选择Common Development and Distribution License (CDDL)协议基于Mozilla public license 1.1,而FSF在2005年发表声明,CDDL与GPL不兼容,并不推荐使用CDDL协议.&lt;&#x2F;p&gt;
&lt;p&gt;根据CDDL 3.1款:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;您以&amp;quot;可执行文件&amp;quot;形式分发,或以其他方式提供&amp;quot;所涵盖的软件&amp;quot;,您也必须以&amp;quot;源代码&amp;quot;形式提供，并且该&amp;quot;源代码&amp;quot;形式必须仅根据本许可条款(CDDL)进行分发.&lt;&#x2F;li&gt;
&lt;li&gt;您必须在分发或以其他方式提供的&amp;quot;所涵盖软件&amp;quot;的&amp;quot;源代码&amp;quot;形式的每份副本中包含此许可(CDDL)的副本.&lt;&#x2F;li&gt;
&lt;li&gt;您必须通知所有收到以&amp;quot;可执行文件&amp;quot;形式分发的&amp;quot;所涵盖的软件&amp;quot;的收件人, 告知他们如何以合理的方式或习惯用于软件交换的媒介获得&amp;quot;所涵盖的软件&amp;quot;的&amp;quot;源代码&amp;quot;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;注意到CDDL协议&amp;quot;所覆盖的软件&amp;quot;分发时也必须使用CDDL协议提供源代码.&lt;&#x2F;p&gt;
&lt;p&gt;CDDL 3.5款:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;您可以根据本许可的条款或您选择的许可的条款分发&amp;quot;所涵盖的软件&amp;quot;的&amp;quot;可执行文件&amp;quot;，其中可能包含与本许可不同的条款，前提是您遵守本许可的条款并且&amp;quot;可执行文件&amp;quot;的许可证不会试图限制&amp;quot;本许可证&amp;quot;规定的权利或更改&amp;quot;源代码&amp;quot;形式中的收件人权利.&lt;&#x2F;li&gt;
&lt;li&gt;如果您以不同的许可证以&amp;quot;可执行文件&amp;quot;分发涵盖软件，则必须绝对清楚地指出，与本许可证不同的任何条款仅由您提供，而不是由初始开发者或贡献者提供。 您在此同意赔偿初始开发者和每位贡献者因您提供的任何此类条款而引起的初始开发者或该贡献者的任何责任。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;所以CDDL允许二进制文件以其他条款分发,但收件人在CDDL3.1款规定的以CDDL协议提供源代码的权利不能被剥夺.&lt;&#x2F;p&gt;
&lt;p&gt;而GPL v2 2.b款:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#fdf6e3;color:#657b83;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;You must cause any work that you distribute or publish, that in
&lt;&#x2F;span&gt;&lt;span&gt;whole or in part contains or is derived from the Program or any
&lt;&#x2F;span&gt;&lt;span&gt;part thereof, to be licensed as a whole at no charge to all third
&lt;&#x2F;span&gt;&lt;span&gt;parties under the terms of this License.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;您必须使您分发或发布的全部或部分包含本程序或其任何部分的内容或源于本程序或其任何部分的任何&amp;quot;作品&amp;quot;不得收费的以本协议授权给任何第三方.
这也就是著名的GPL感染, 任何&amp;quot;作品&amp;quot;, 如果是派生自GPLv2的程序,或者包含GPLv2的程序的部分或全部,那么这个程序就被感染了,该程序的全部代码就需要以GPLv2的协议发布.&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是,GPL不限制任何不进行再分发的修改.例如修改某GPL授权的服务器程序,然后运行该程序为他人提供服务.由于该服务器程序本身没有分发,因此不需要公开其源代码.此外在本地混合Linux和ZFS的代码,并编译出内核也不违反任何协议,但该内核不能分发给任何人.&lt;&#x2F;p&gt;
&lt;p&gt;但是,对作品,尤其是派生作品的定义在各国的版权法中定义各不相同.因此将原本是属于Solaris的ZFS和Linux编译出一个内核,是否仍是派生作品,则充满了争议.
Linus Torvalds多次声明, Linux内核的GPL例外只适用于和内核交互的用户空间程序, 任何链接到内核的模块均被GPL协议覆盖.
但是NVIDIA的闭源显卡驱动则通过添加LGPL的兼容层隔离了闭源的显卡驱动,避免其闭源软件被GPL感染.Linus Torvalds曾多次反对该行为,包括公开发表NVIDIA是最烂的公司, &amp;quot;So, nvidia fxxk you&amp;quot;.
但是,没有针对NVIDIA该行为的法律行动.&lt;&#x2F;p&gt;
&lt;p&gt;由于内部律师评估后认为发布ZFS on Linux的二进制文件没有法律风险, 2016年, Canonical决定在Ubuntu 16.04中发布预编译的zfs on linux内核模块. 按照FSF的理论,这直接违反了GPL的协议, FSF主席Richard Stallman发表了&lt;a href=&quot;https:&#x2F;&#x2F;www.fsf.org&#x2F;licensing&#x2F;zfs-and-linux&quot;&gt;声明&lt;&#x2F;a&gt;, 认为Linux和ZFS代码链接成二进制文件时,最终的程序(Linux内核)构成了&amp;quot;作品&amp;quot;,无论该链接是镜头链接还是动态链接(即内核模块),FSF认为该问题的最终的解决方案是ZFS的作者以GPL兼容的协议重新发布ZFS的源代码.FSF也表示如果Linux版权所有者不追责, 不代表GPL不起作用, 同时敦促Linux应该升级到GPL v3(Linus Torvalds多次表示Linux不会使用GPL v3).&lt;&#x2F;p&gt;
&lt;p&gt;2019年, Linux内核维护者和最活跃的开发者Greg Kroah-Hartman提交了一个commit, 阻止非GPL代码使用FPU的函数(通常内核不允许使用FPU,因为FPU的寄存器数量多大小大,要保存FPU的寄存器的值到内存才可以使用FPU同时不影响用户态程序,在使用完FPU后还需要手动恢复FPU寄存器的值,而该保存和恢复需要手动调用kernel_fpu_begin和kernel_fpu_end函数).ZFS使用了SSE&#x2F;AVX来加速允许,而因为无法访问这两个函数,ZFS只能不使用FPU,这导致性能下降. 2020年, Linus Torvalds在论坛上被问到&lt;a href=&quot;https:&#x2F;&#x2F;www.realworldtech.com&#x2F;forum&#x2F;?threadid=189711&amp;amp;curpostid=189841&quot;&gt;为何Linux破坏了ZFS的功能&lt;&#x2F;a&gt;, Linus表示他无法维护任何外部的内核模块, 也不能将ZFS提交到Linux里, &amp;quot;在我收到甲骨文的主要法律顾问或最好由拉里·埃里森本人签署的甲骨文正式信件之前，我无法合并ZFS的任何工作. 其他人认为将ZFS代码合并到内核中是可以的，使用模块接口也可以，这是他们的决定。但是考虑到Oracle的诉讼性质以及有关许可的问题，我永远都不会感到安全.而且我对某些&#x27;ZFS填充层&#x27;东西完全不感兴趣，有些人似乎认为这会隔离两个项目。这对我们这边没有任何价值，而且考虑到Oracle的接口版权诉讼（指Oracle指控Google的Android复制了Java的API），我不认为这是对的。&amp;quot; 事实上, Oracle并不关心来自Sun的Solaris的未来, 而是关心自己的Oracle Linux,和诞生于自己的Btrfs. Oracle也已经把另一个来自Solaris的CDDL授权的Dtrace以GPL授权重新发布, 但是没有重新发布ZFS,可能就是因为~~烂泥扶不上墙的~~Btrfs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;firewall&quot;&gt;Firewall&lt;&#x2F;h3&gt;
&lt;p&gt;OpenBSD的开发者喜欢造轮子,尤其是因为原软件的协议不符合他们的心理预期.IPFilter曾经是一个适用于Unix的开源防火墙,但是OpenBSD认为其协议有问题, 开发了自己的版本: Packet Filter (PF, pf). 随后pf被移植到FreeBSD, Apple Darwin, NetBSD, DragonFly BSD, Solaris, QNX. pfSense和OPNsense是基于FreeBSD和pf的开源路由器&#x2F;防火墙操作系统.&lt;&#x2F;p&gt;
&lt;p&gt;Linux有和pf相似功能的netfilter&#x2F;iptables.说到底netfilter和pf的功能差不多, 尤其在各大云厂商的疯狂优化下, 二者性能都得到了极致的优化.&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是netflix是FreeBSD和pf的一个重要的使用者.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bpf&quot;&gt;BPF&lt;&#x2F;h3&gt;
&lt;p&gt;Berkeley Packet Filter, 伯克利包过滤器, 简称BPF, 是一种Unix内核上的用于处理网络数据包的寄存器虚拟机, 因为工作在内核态, 避免了用户态程序频繁的复制, 因此性能很高.Linux和BSD都支持BPF.&lt;&#x2F;p&gt;
&lt;p&gt;Linux基于BPF的思想开发了eBPF(extended BPF), 这种虚拟机不仅可以拦截网络包, 还可以hook各种内核子系统, 追踪其运行轨迹.LLVM和gcc还支持使用高级语言编写eBPF的程序.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kqueue&quot;&gt;Kqueue&lt;&#x2F;h3&gt;
&lt;p&gt;传统Unix 拥有 select(2)和poll(2)系统调用用于监听文件描述符, 但是针对大量文件时poll的效率很低. Linux因此加入了改进的epoll系统调用, 可以监听一系列事件, 并在时间触发时得到通知. kqueue是FreeBSD内核的一个事件队列机制, 不仅可以处理文件描述符,也可以处理信号, 异步IO,子进程等事件. kqueue随后被移植到netbsd, openbsd, dragonfly bsd和macOS.长期以来, Linux epoll的设计被认为不如BSD的kqueue和Windows&#x2F;AIX&#x2F;Solaris的IOCP, 直到类似功能的io_uring的出现.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jail&quot;&gt;jail&lt;&#x2F;h3&gt;
&lt;p&gt;jail是一个高级的chroot, 隔离了文件系统, 网络, pid 和uid, 功能类似Linux的cgroup, 但是出现的更早.然而基于cgroup的docker生态远好于jail.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bhyve&quot;&gt;bhyve&lt;&#x2F;h3&gt;
&lt;p&gt;bhyve是FreeBSD的hypervisor和虚拟机管理器, 类似qemu&#x2F;KVM&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>LLVM cross-compiled Linux From Scratch: ZFS on root (Optional)</title>
            <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/llvm-compile-zfs-on-root/</link>
            <guid>https://12101111.github.io/llvm-compile-zfs-on-root/</guid>
            <description>&lt;p&gt;本文章是LLVM编译Linux系统的第三篇文章,以一个实际场景介绍如何使用LLVM&#x2F;Clang&#x2F;musl工具链编译出适合于启动根分区在ZFS文件系统的Linux系统.&lt;&#x2F;p&gt;
&lt;p&gt;ZFS原是Solaris操作系统的文件系统,由Open Solaris项目以CDDL协议开源,随后Oracle收购Sun,将Solaris转为闭源系统,原开发者以illumos为名继续开发开源的Solaris系统,并创建OpenZFS项目继续ZFS的开发.ZFS先后被移植到FreeBSD,Linux,macOS和Windows.&lt;&#x2F;p&gt;
&lt;p&gt;然而在Linux平台,由于CDDL开源协议和GPLv2协议都要求衍生代码不得更改许可证,因而互不兼容,
这导致分发包含ZFS on Linux的Linux内核存在法律风险.
同样的,由于有可能被Oracle起诉,Torvalds linus拒绝合并ZFS到Linux,除非Oracle以GPLv2重新发布ZFS的代码.
ZFS一直以树外代码的形式开发,正如nvidia这样的闭源驱动一样在用户计算机上通过DKMS编译成为内核模块.
但实际上用户可以将Linux和ZFS的代码混合,并将ZFS编译进内核而不是模块(注意,这样的内核不能分发给他人).&lt;&#x2F;p&gt;
&lt;p&gt;但即使将ZFS编译为内置模块,Linux也不能不使用initramfs直接从ZFS分区上启动(比如通过启动参数指定启动分区),&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;zfsonlinux&#x2F;zfs&#x2F;issues&#x2F;4300&quot;&gt;此问题有待日后解决&lt;&#x2F;a&gt;,目前需要一个initramfs在用户空间挂载根分区.&lt;&#x2F;p&gt;
&lt;p&gt;本文将使用之前编译的LLVM工具链编译内核与initramfs工具.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>为什么Linux不能运行FreeBSD的elf</title>
            <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/linux-freebsd-elf-compat/</link>
            <guid>https://12101111.github.io/linux-freebsd-elf-compat/</guid>
            <description>&lt;h1 id=&quot;linuxhe-freebsddu-shi-yong-elf-dan-shi-zhu-duo-chai-yi-dao-zhi-er-zhe-er-jin-zhi-bing-bu-jian-rong&quot;&gt;Linux和FreeBSD都使用ELF,但是诸多差异导致二者二进制并不兼容&lt;&#x2F;h1&gt;
&lt;p&gt;查看ELF信息可以使用两个程序,&lt;code&gt;file&lt;&#x2F;code&gt;和&lt;code&gt;readelf&lt;&#x2F;code&gt;
file 这个程序可以快速识别ELF文件的不同之处(也可以识别其他文件).readelf则可以读取大部分ELF文件的信息.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cyu-yan-ku-bu-tong-dao-zhi-de-jia-zai-qi-he-abichai-yi&quot;&gt;C语言库不同导致的加载器和ABI差异&lt;&#x2F;h2&gt;
&lt;p&gt;除了少数如busybox的程序,绝大多数程序都动态链接到C语言库.
不同的C语言库使用不同的加载器（interpreter），这是阻碍绝大多数elf文件在各个系统之间兼容的主要因素，甚至同为Linux,glibc和musl也互不兼容。&lt;&#x2F;p&gt;
&lt;p&gt;这是静态链接的Linux下的busybox (ARM64)
bin&#x2F;busybox: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, stripped
这是动态链接到GNU libc的Linux下的bash
&#x2F;bin&#x2F;bash: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 3.2.0, stripped
这是动态链接到musl libc的Linux下的zfs
zfs: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-musl-x86_64.so.1, stripped
这是FreeBSD的zfs
sbin&#x2F;zfs: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), dynamically linked, interpreter &#x2F;libexec&#x2F;ld-elf.so.1, for FreeBSD 12.1 (1201511), FreeBSD-style, stripped
首先最明显的就是interpreter不同,当然根本原因还是C语言库不同.&lt;&#x2F;p&gt;
&lt;p&gt;使用&lt;code&gt;readelf -l&lt;&#x2F;code&gt;可以查看程序头表(Program header table),interpreter的位置就在这里.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;output&quot; style=&quot;background-color:#fdf6e3;color:#657b83;&quot; class=&quot;language-output &quot;&gt;&lt;code class=&quot;language-output&quot; data-lang=&quot;output&quot;&gt;&lt;span&gt;$ readelf -l sbin&#x2F;zfs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Elf 文件类型为 EXEC (可执行文件)
&lt;&#x2F;span&gt;&lt;span&gt;Entry point 0x20c000
&lt;&#x2F;span&gt;&lt;span&gt;There are 11 program headers, starting at offset 64
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;程序头：
&lt;&#x2F;span&gt;&lt;span&gt;  Type           Offset             VirtAddr           PhysAddr
&lt;&#x2F;span&gt;&lt;span&gt;                 FileSiz            MemSiz              Flags  Align
&lt;&#x2F;span&gt;&lt;span&gt;  PHDR           0x0000000000000040 0x0000000000200040 0x0000000000200040
&lt;&#x2F;span&gt;&lt;span&gt;                 0x0000000000000268 0x0000000000000268  R      0x8
&lt;&#x2F;span&gt;&lt;span&gt;  INTERP         0x00000000000002a8 0x00000000002002a8 0x00000000002002a8
&lt;&#x2F;span&gt;&lt;span&gt;                 0x0000000000000015 0x0000000000000015  R      0x1
&lt;&#x2F;span&gt;&lt;span&gt;      [Requesting program interpreter: &#x2F;libexec&#x2F;ld-elf.so.1]
&lt;&#x2F;span&gt;&lt;span&gt;  LOAD           0x0000000000000000 0x0000000000200000 0x0000000000200000
&lt;&#x2F;span&gt;&lt;span&gt;                 0x000000000000be84 0x000000000000be84  R      0x1000
&lt;&#x2F;span&gt;&lt;span&gt;  LOAD           0x000000000000c000 0x000000000020c000 0x000000000020c000
&lt;&#x2F;span&gt;&lt;span&gt;                 0x000000000000cb50 0x000000000000cb50  R E    0x1000
&lt;&#x2F;span&gt;&lt;span&gt;  LOAD           0x0000000000019000 0x0000000000219000 0x0000000000219000
&lt;&#x2F;span&gt;&lt;span&gt;                 0x00000000000001e0 0x00000000000001e0  RW     0x1000
&lt;&#x2F;span&gt;&lt;span&gt;  LOAD           0x000000000001a000 0x000000000021a000 0x000000000021a000
&lt;&#x2F;span&gt;&lt;span&gt;                 0x0000000000000c80 0x00000000000015b8  RW     0x1000
&lt;&#x2F;span&gt;&lt;span&gt;  DYNAMIC        0x0000000000019028 0x0000000000219028 0x0000000000219028
&lt;&#x2F;span&gt;&lt;span&gt;                 0x00000000000001b0 0x00000000000001b0  RW     0x8
&lt;&#x2F;span&gt;&lt;span&gt;  GNU_RELRO      0x0000000000019000 0x0000000000219000 0x0000000000219000
&lt;&#x2F;span&gt;&lt;span&gt;                 0x00000000000001e0 0x00000000000001e0  R      0x1
&lt;&#x2F;span&gt;&lt;span&gt;  GNU_EH_FRAME   0x000000000000ad48 0x000000000020ad48 0x000000000020ad48
&lt;&#x2F;span&gt;&lt;span&gt;                 0x00000000000002b4 0x00000000000002b4  R      0x4
&lt;&#x2F;span&gt;&lt;span&gt;  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
&lt;&#x2F;span&gt;&lt;span&gt;                 0x0000000000000000 0x0000000000000000  RW     0x0
&lt;&#x2F;span&gt;&lt;span&gt;  NOTE           0x00000000000002c0 0x00000000002002c0 0x00000000002002c0
&lt;&#x2F;span&gt;&lt;span&gt;                 0x0000000000000030 0x0000000000000030  R      0x4
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt; Section to Segment mapping:
&lt;&#x2F;span&gt;&lt;span&gt;  段节...
&lt;&#x2F;span&gt;&lt;span&gt;   00
&lt;&#x2F;span&gt;&lt;span&gt;   01     .interp
&lt;&#x2F;span&gt;&lt;span&gt;   02     .interp .note.tag .dynsym .gnu.version .gnu.version_r .gnu.hash .hash .dynstr .rela.dyn .rela.plt .rodata .eh_frame_hdr .eh_frame
&lt;&#x2F;span&gt;&lt;span&gt;   03     .text .init .fini .plt
&lt;&#x2F;span&gt;&lt;span&gt;   04     .ctors .dtors .jcr .dynamic .got
&lt;&#x2F;span&gt;&lt;span&gt;   05     .data .got.plt .bss
&lt;&#x2F;span&gt;&lt;span&gt;   06     .dynamic
&lt;&#x2F;span&gt;&lt;span&gt;   07     .ctors .dtors .jcr .dynamic .got
&lt;&#x2F;span&gt;&lt;span&gt;   08     .eh_frame_hdr
&lt;&#x2F;span&gt;&lt;span&gt;   09
&lt;&#x2F;span&gt;&lt;span&gt;   10     .note.tag
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在Linux下运行FreeBSD的程序就会提示&lt;code&gt;zsh: 没有那个文件或目录: sbin&#x2F;zfs&lt;&#x2F;code&gt;,实际上是interpreter找不到的通用提示.(当然也很具有迷惑性,因为文件明明就在那里),&lt;&#x2F;p&gt;
&lt;p&gt;当然把interpreter放过去也没有用,直接显示&lt;code&gt;[1]    18145 segmentation fault  sbin&#x2F;zfs&lt;&#x2F;code&gt;, 可见Linux并不检查其他的东西就直接运行这个elf可执行文件,结果就是直接段错误. dmesg有如下日志:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;&lt;code&gt;&lt;span&gt;[ 9734.919582] ld-elf.so.1[12587]: segfault at 0 ip 00007f28598cda3f sp 00007fffce706b38 error 4 in ld-elf.so.1[7f28598cd000+1a000]
&lt;&#x2F;span&gt;&lt;span&gt;[ 9734.919594] Code: 57 08 48 89 c7 5d e9 c0 58 00 00 55 48 89 e5 41 57 41 56 41 55 41 54 53 48 81 ec b8 0a 00 00 49 89 d4 48 8d 47 08 48 89 45 b8 &amp;lt;48&amp;gt; 8b 1f 48 89 d8 48 c1 e0 20 48 b9 00 00 00 00 01 00 00 00 48 01
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;sao-cao-zuo&quot;&gt;骚操作&lt;&#x2F;h2&gt;
&lt;p&gt;通常不同的interpreter下的库不能相互加载,但是实际上是可以通过一些兼容层(shim)使他们共存.
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;AdelieLinux&#x2F;gcompat&quot;&gt;AdelieLinux&#x2F;gcompat&lt;&#x2F;a&gt; 这个项目实现了一个musl下的glibc的加载器,使得musl可以执行部分glibc的程序(通过补全符号的方式),但是实际使用上,由于不同libc之间不只是符号不同,ABI也不同,比如一些结构体的大小不一样,这样直接兼容是不太可能的.我实际测试来看,gcompat能在musl系统上执行nvidia驱动的&lt;code&gt;nvidia-smi&lt;&#x2F;code&gt;命令,但是启动Xorg会直接段错误.&lt;&#x2F;p&gt;
&lt;p&gt;FreeBSD这边也有类似的骚操作: https:&#x2F;&#x2F;github.com&#x2F;shkhln&#x2F;nvshim 用Linux兼容层下的Nvidia驱动使得FreeBSD的程序用上Nvidia的Vulkan
这里插播一句fxxk nvidia.总之这种操作实用价值不高.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;elfde-abizi-duan&quot;&gt;ELF的ABI字段&lt;&#x2F;h2&gt;
&lt;p&gt;BSD更加接近Unix©,因此比Linux要严谨一些,至少会检查ABI的类型.这个信息位于ELF头的0x7位置,可以用&lt;code&gt;readelf -h&lt;&#x2F;code&gt;查看:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;&lt;code&gt;&lt;span&gt;readelf -h zfs
&lt;&#x2F;span&gt;&lt;span&gt;ELF 头：
&lt;&#x2F;span&gt;&lt;span&gt;  Magic：  7f 45 4c 46 02 01 01 09 00 00 00 00 00 00 00 00
&lt;&#x2F;span&gt;&lt;span&gt;  类别:                              ELF64
&lt;&#x2F;span&gt;&lt;span&gt;  数据:                              2 补码，小端序 (little endian)
&lt;&#x2F;span&gt;&lt;span&gt;  Version:                           1 (current)
&lt;&#x2F;span&gt;&lt;span&gt;  OS&#x2F;ABI:                            UNIX - FreeBSD
&lt;&#x2F;span&gt;&lt;span&gt;  ABI 版本:                          0
&lt;&#x2F;span&gt;&lt;span&gt;  类型:                              EXEC (可执行文件)
&lt;&#x2F;span&gt;&lt;span&gt;  系统架构:                          Advanced Micro Devices X86-64
&lt;&#x2F;span&gt;&lt;span&gt;  版本:                              0x1
&lt;&#x2F;span&gt;&lt;span&gt;  入口点地址：              0x20c000
&lt;&#x2F;span&gt;&lt;span&gt;  程序头起点：              64 (bytes into file)
&lt;&#x2F;span&gt;&lt;span&gt;  Start of section headers:          110648 (bytes into file)
&lt;&#x2F;span&gt;&lt;span&gt;  标志：             0x0
&lt;&#x2F;span&gt;&lt;span&gt;  Size of this header:               64 (bytes)
&lt;&#x2F;span&gt;&lt;span&gt;  Size of program headers:           56 (bytes)
&lt;&#x2F;span&gt;&lt;span&gt;  Number of program headers:         11
&lt;&#x2F;span&gt;&lt;span&gt;  Size of section headers:           64 (bytes)
&lt;&#x2F;span&gt;&lt;span&gt;  Number of section headers:         30
&lt;&#x2F;span&gt;&lt;span&gt;  Section header string table index: 29
&lt;&#x2F;span&gt;&lt;span&gt;$ readelf -h &#x2F;sbin&#x2F;zfs
&lt;&#x2F;span&gt;&lt;span&gt;ELF 头：
&lt;&#x2F;span&gt;&lt;span&gt;  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
&lt;&#x2F;span&gt;&lt;span&gt;  类别:                              ELF64
&lt;&#x2F;span&gt;&lt;span&gt;  数据:                              2 补码，小端序 (little endian)
&lt;&#x2F;span&gt;&lt;span&gt;  Version:                           1 (current)
&lt;&#x2F;span&gt;&lt;span&gt;  OS&#x2F;ABI:                            UNIX - System V
&lt;&#x2F;span&gt;&lt;span&gt;  ABI 版本:                          0
&lt;&#x2F;span&gt;&lt;span&gt;  类型:                              EXEC (可执行文件)
&lt;&#x2F;span&gt;&lt;span&gt;  系统架构:                          Advanced Micro Devices X86-64
&lt;&#x2F;span&gt;&lt;span&gt;  版本:                              0x1
&lt;&#x2F;span&gt;&lt;span&gt;  入口点地址：              0x20e000
&lt;&#x2F;span&gt;&lt;span&gt;  程序头起点：              64 (bytes into file)
&lt;&#x2F;span&gt;&lt;span&gt;  Start of section headers:          126648 (bytes into file)
&lt;&#x2F;span&gt;&lt;span&gt;  标志：             0x0
&lt;&#x2F;span&gt;&lt;span&gt;  Size of this header:               64 (bytes)
&lt;&#x2F;span&gt;&lt;span&gt;  Size of program headers:           56 (bytes)
&lt;&#x2F;span&gt;&lt;span&gt;  Number of program headers:         11
&lt;&#x2F;span&gt;&lt;span&gt;  Size of section headers:           64 (bytes)
&lt;&#x2F;span&gt;&lt;span&gt;  Number of section headers:         28
&lt;&#x2F;span&gt;&lt;span&gt;  Section header string table index: 27
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Linux的ABI是默认的0号(System V), FreeBSD使用0x9,OpenBSD使用0xC,NetBSD使用0x2.但实际上0x3是分给Linux的,由于GNU的&lt;a href=&quot;https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=12913&quot;&gt;一些混乱的操作&lt;&#x2F;a&gt;而没有用上.&lt;&#x2F;p&gt;
&lt;p&gt;FreeBSD则靠这个来检查是否应该用linux兼容层来执行elf文件,还有一个程序&lt;a href=&quot;https:&#x2F;&#x2F;www.freebsd.org&#x2F;cgi&#x2F;man.cgi?query=brandelf&amp;amp;sektion=1&amp;amp;manpath=freebsd-release-ports&quot;&gt;brandelf&lt;&#x2F;a&gt;来修改ABI信息.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;syscall-abibu-jian-rong&quot;&gt;syscall ABI不兼容&lt;&#x2F;h2&gt;
&lt;p&gt;更深层次的讲,Linux和FreeBSD内核的系统调用也互不兼容.Linux提供稳定的syscall ABI, FreeBSD在每一个大版本中保证内核和用户库的ABI都不变,但是不在版本间做出保证.FreeBSD的Linux兼容层内核模块就需要把Linux的系统调用翻译到FreeBSD上(非常类似windows10的WSL1).&lt;&#x2F;p&gt;
&lt;p&gt;FreeBSD是开源的,Linux兼容层代码并不复杂,就是大量的转换代码:&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;freebsd&#x2F;freebsd&#x2F;tree&#x2F;master&#x2F;sys&#x2F;compat&#x2F;linux&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>逆向Speedtest.net 的API和协议</title>
            <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/speedtest-net/</link>
            <guid>https://12101111.github.io/speedtest-net/</guid>
            <description>&lt;p&gt;目前在国内乃至全球范围内能跑满5G移动网络全速下载的服务器也没有几个,然而Speedtest.net是一个例外.&lt;&#x2F;p&gt;
&lt;p&gt;处于营销等目的,全国各地移动联通电信架设了多个(63个)Speedtest的测速服务器,其中命名包含5G的有15个(而且全球仅中国的服务器如此),可见运营商大概率在宣传5G网速时也会使用自己架设的Speedtest服务器,以接近理论上的峰值速度.&lt;&#x2F;p&gt;
&lt;p&gt;处于自动化测速的考虑,需要研究Speedtest的测速机制并且命令行脚本化.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>5G芯片及终端和WIFI6芯片及设备</title>
            <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/5g-wifi6/</link>
            <guid>https://12101111.github.io/5g-wifi6/</guid>
            <description>&lt;h1 id=&quot;5gzhong-duan-xin-pian&quot;&gt;5G终端芯片&lt;&#x2F;h1&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;企业&lt;&#x2F;th&gt;&lt;th&gt;商标&lt;&#x2F;th&gt;&lt;th&gt;基带型号&lt;&#x2F;th&gt;&lt;th&gt;制程&lt;&#x2F;th&gt;&lt;th&gt;频段&lt;&#x2F;th&gt;&lt;th&gt;模式&lt;&#x2F;th&gt;&lt;th&gt;多模&lt;&#x2F;th&gt;&lt;th&gt;EN-DC&lt;&#x2F;th&gt;&lt;th&gt;频宽,MIMO,速率&lt;&#x2F;th&gt;&lt;th&gt;双卡&lt;&#x2F;th&gt;&lt;th&gt;兼容Soc&lt;&#x2F;th&gt;&lt;th&gt;集成方式&lt;&#x2F;th&gt;&lt;th&gt;在售终端&lt;&#x2F;th&gt;&lt;th&gt;时间&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Qualcomm&lt;&#x2F;td&gt;&lt;td&gt;Snapdragon&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.qualcomm.com&#x2F;products&#x2F;snapdragon-x50-5g-modem&quot;&gt;X50&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;10nm&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;TDD,NSA&lt;&#x2F;td&gt;&lt;td&gt;5G&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;td&gt;mmWave:800MHz,8 carriers,2x2MIMOsub-6 GHz:100MHz,4x4 MIMO，5Gbps download&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;845,850,855,8cx&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.ifixit.com&#x2F;Guide&#x2F;Samsung+Galaxy+Note10++5G+%E6%8B%86%E8%A7%A3&#x2F;125590&quot;&gt;外挂&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;All others&lt;&#x2F;td&gt;&lt;td&gt;2016-2019&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;海思&lt;&#x2F;td&gt;&lt;td&gt;Balong&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.hisilicon.com&#x2F;en&#x2F;Products&#x2F;ProductList&#x2F;Balong&quot;&gt;5G01&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;10nm?&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;5G&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;2.3Gbps download&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;外挂&lt;&#x2F;td&gt;&lt;td&gt;华为5G CPE(停产)&lt;&#x2F;td&gt;&lt;td&gt;2018-02&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Intel&lt;&#x2F;td&gt;&lt;td&gt;XMM&lt;&#x2F;td&gt;&lt;td&gt;8060&lt;&#x2F;td&gt;&lt;td&gt;14nm+&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;6Gbps download&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A&lt;&#x2F;td&gt;&lt;td&gt;Intel CPU&lt;&#x2F;td&gt;&lt;td&gt;外挂&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;2018-10-14取消&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Intel&lt;&#x2F;td&gt;&lt;td&gt;XMM&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;newsroom.intel.com&#x2F;news&#x2F;intel-accelerates-timing-intel-xmm-8160-5g-multimode-modem-support-broad-global-5g-rollouts&#x2F;#gs.3dbd3a&quot;&gt;8160&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;10nm&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;6Gbps download&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A&lt;&#x2F;td&gt;&lt;td&gt;Intel CPU&lt;&#x2F;td&gt;&lt;td&gt;外挂&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;2019-04-16取消&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Samsung&lt;&#x2F;td&gt;&lt;td&gt;Exynos&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.samsung.com&#x2F;semiconductor&#x2F;minisite&#x2F;exynos&#x2F;cn&#x2F;products&#x2F;modemrf&#x2F;exynos-modem-5100&#x2F;&quot;&gt;5100&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;10nm,8nm&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;Yes?&lt;&#x2F;td&gt;&lt;td&gt;sub-6 GHz:100MHz,2Gbps,mmWave:6Gbps&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;Exynos 9810,9820,9825&lt;&#x2F;td&gt;&lt;td&gt;外挂&lt;&#x2F;td&gt;&lt;td&gt;Galaxy &lt;a href=&quot;https:&#x2F;&#x2F;www.techinsights.com&#x2F;blog&#x2F;samsung-galaxy-s10-5g-teardown&quot;&gt;S10 5G&lt;&#x2F;a&gt;,Note10 5G,Fold&lt;&#x2F;td&gt;&lt;td&gt;2018-2019&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;海思&lt;&#x2F;td&gt;&lt;td&gt;Balong&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.hisilicon.com&#x2F;en&#x2F;Products&#x2F;ProductList&#x2F;Balong&quot;&gt;5000&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;7nm&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;FDD,TDD SA,NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;sub-6 GHz:100MHz 4.6Gbps download 2.5Gbps up,mmWave:6.5Gbps download 3.5Gbps up&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;980&lt;&#x2F;td&gt;&lt;td&gt;外挂&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.ifixit.com&#x2F;Guide&#x2F;%E5%8D%8E%E4%B8%BA+Mate+20+X+5G+%E6%8B%86%E8%A7%A3&#x2F;124808&quot;&gt;Mate20 X&lt;&#x2F;a&gt;,华为5G CPE Pro&lt;&#x2F;td&gt;&lt;td&gt;2018-02&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;海思&lt;&#x2F;td&gt;&lt;td&gt;麒麟&lt;&#x2F;td&gt;&lt;td&gt;990 5G&lt;&#x2F;td&gt;&lt;td&gt;7nm EUV&lt;&#x2F;td&gt;&lt;td&gt;sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;FDD,TDD SA,NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;2.3Gbps download 1.25Gbps up&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;990 5G&lt;&#x2F;td&gt;&lt;td&gt;Soc&lt;&#x2F;td&gt;&lt;td&gt;Mate 30 5G&lt;&#x2F;td&gt;&lt;td&gt;2019-09&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;紫光展锐&lt;&#x2F;td&gt;&lt;td&gt;马卡鲁技术平台&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.unisoc.com&#x2F;cn&#x2F;%E7%B4%AB%E5%85%89%E5%B1%95%E9%94%90%E5%8F%91%E5%B8%835g%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0%E2%80%94%E9%A9%AC%E5%8D%A1%E9%B2%81%E5%8F%8A%E5%85%B6%E9%A6%96%E6%AC%BE5g%E5%9F%BA%E5%B8%A6%E8%8A%AF%E7%89%87%E2%80%94%E6%98%A5%E8%97%A4510&quot;&gt;春藤510&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;12nm&lt;&#x2F;td&gt;&lt;td&gt;sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;100MHz&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;Soc&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;2019&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Qualcomm&lt;&#x2F;td&gt;&lt;td&gt;Snapdragon&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.qualcomm.com&#x2F;products&#x2F;snapdragon-x55-5g-modem&quot;&gt;X55&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;7nm&lt;&#x2F;td&gt;&lt;td&gt;mmWave,sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;FDD,TDD SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;Yes?&lt;&#x2F;td&gt;&lt;td&gt;mmWave:800MHz,8 carriers,2x2MIMO，sub-6 GHz:200MHz,4x4 MIMO，7Gbps Download 3Gbps up&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;855,855+,8cx&lt;&#x2F;td&gt;&lt;td&gt;外挂&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;2019&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;MediaTek&lt;&#x2F;td&gt;&lt;td&gt;Helio&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;i.mediatek.com&#x2F;mediatek-5g-cn&quot;&gt;M70&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;7nm&lt;&#x2F;td&gt;&lt;td&gt;sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;2载波,4.7Gbps download 2.5Gbps upload&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;Helio M70&lt;&#x2F;td&gt;&lt;td&gt;Soc&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;2020&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Samsung&lt;&#x2F;td&gt;&lt;td&gt;Exynos&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.samsung.com&#x2F;semiconductor&#x2F;minisite&#x2F;exynos&#x2F;products&#x2F;mobileprocessor&#x2F;exynos-980&#x2F;&quot;&gt;980&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;8nm?&lt;&#x2F;td&gt;&lt;td&gt;sub-6 GHz&lt;&#x2F;td&gt;&lt;td&gt;SA&#x2F;NSA&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;3&#x2F;4&#x2F;5G&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;2.55Gbps download,1.28Gbps upload&lt;&#x2F;td&gt;&lt;td&gt;?&lt;&#x2F;td&gt;&lt;td&gt;Exynos 980&lt;&#x2F;td&gt;&lt;td&gt;Soc&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;2020&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h1 id=&quot;wifi6&quot;&gt;WIFI6&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wikidevi.com&#x2F;wiki&#x2F;List_of_802.11ax_Hardware#Automatically_generated_tables_5&quot;&gt;List of 802.11ax Hardware&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wifi6-wireless-router&quot;&gt;WIFI6 Wireless Router&lt;&#x2F;h2&gt;
&lt;p&gt;Broadcom:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;BCM43684(家用): 5Ghz 4x4 160MHz(4.8Gbps)&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;产品&lt;&#x2F;th&gt;&lt;th&gt;Soc&lt;&#x2F;th&gt;&lt;th&gt;WIFI芯片&lt;&#x2F;th&gt;&lt;th&gt;天线数量&lt;&#x2F;th&gt;&lt;th&gt;2.5Gbps WAN&#x2F;LAN&lt;&#x2F;th&gt;&lt;th&gt;1Gbps WAN&lt;&#x2F;th&gt;&lt;th&gt;1Gbps LAN&lt;&#x2F;th&gt;&lt;th&gt;价格&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;item.jd.com&#x2F;100000676959.html&quot;&gt;ASUS ROG GT-AX11000&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;BCM4908(4xA53@1.8Ghz)&lt;&#x2F;td&gt;&lt;td&gt;BCM43684 x2&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;￥4699&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;item.jd.com&#x2F;100000529143.html&quot;&gt;ASUS RT-AX88U&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;BCM4908&lt;&#x2F;td&gt;&lt;td&gt;BCM43684 x2&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;￥2799&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;item.jd.com&#x2F;100004671592.html&quot;&gt;Asus AiMesh AX6100M&lt;&#x2F;a&gt;(RT-AX92U x2)&lt;&#x2F;td&gt;&lt;td&gt;BCM4906(2xA53@1.8Ghz)&lt;&#x2F;td&gt;&lt;td&gt;BCM4352(ac)+BCM43684(ax)&lt;&#x2F;td&gt;&lt;td&gt;4x2&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;1x2&lt;&#x2F;td&gt;&lt;td&gt;4x2&lt;&#x2F;td&gt;&lt;td&gt;￥3699&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.com&#x2F;dp&#x2F;B07PNR2VMD&quot;&gt;Netgear AX12 RAX200&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;BCM4908&lt;&#x2F;td&gt;&lt;td&gt;BCM43684 x2&lt;&#x2F;td&gt;&lt;td&gt;8(隐藏式)&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;$599&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;item.jd.com&#x2F;100005565864.html&quot;&gt;Netgear RAX80&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;BCM4908&lt;&#x2F;td&gt;&lt;td&gt;BCM43684 x2&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;￥2999&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.tp-link.com&#x2F;us&#x2F;products&#x2F;details&#x2F;cat-9_Archer-AX11000_V1-preview.html&quot;&gt;TP-LINK Archer AX11000&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;BCM4908&lt;&#x2F;td&gt;&lt;td&gt;BCM43684 x2&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;$450&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;BCM6755: 2x2&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ASUS RT-AX92U (BCM6755+BCM43684)&lt;&#x2F;li&gt;
&lt;li&gt;TP-LINK Archer AX1500&lt;&#x2F;li&gt;
&lt;li&gt;TP-LINK Archer AX1800&lt;&#x2F;li&gt;
&lt;li&gt;TP-LINK Deco X10&lt;&#x2F;li&gt;
&lt;li&gt;TP-LINK RE705X&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;BCM43694(企业AP): 4x4&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Cisco C9115AXI-B&lt;&#x2F;li&gt;
&lt;li&gt;H3C WA6528&lt;&#x2F;li&gt;
&lt;li&gt;D-Link DIR-X9000&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;BCM43698(仅通过WIFI联盟认证,未上市)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Qualcomm:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;QCN5054: 5Ghz 4x4 160MHz(4.8Gbps)&lt;&#x2F;li&gt;
&lt;li&gt;QCN5024: 2.4Ghz 4x4(1.2Gbps)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;产品&lt;&#x2F;th&gt;&lt;th&gt;Soc&lt;&#x2F;th&gt;&lt;th&gt;WIFI芯片&lt;&#x2F;th&gt;&lt;th&gt;天线数量&lt;&#x2F;th&gt;&lt;th&gt;10Gbps&#x2F;2.5Gbps WAN&lt;&#x2F;th&gt;&lt;th&gt;1Gbps WAN&lt;&#x2F;th&gt;&lt;th&gt;1Gbps LAN&lt;&#x2F;th&gt;&lt;th&gt;价格&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;ASUS RT-AX89X&lt;&#x2F;td&gt;&lt;td&gt;IPQ8078(4xA53@2.2Ghz)&lt;&#x2F;td&gt;&lt;td&gt;QCN5054+QCN5024&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;10G RJ45 + 10G SFP+&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;￥5999未上市&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ASUS GT-AX6000&lt;&#x2F;td&gt;&lt;td&gt;IPQ8074(4xA53@2.0Ghz)&lt;&#x2F;td&gt;&lt;td&gt;QCN5054+QCN5024&lt;&#x2F;td&gt;&lt;td&gt;8?&lt;&#x2F;td&gt;&lt;td&gt;10Gbps&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;未发布&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Netgear RAX120 (Nighthawk AX12)&lt;&#x2F;td&gt;&lt;td&gt;IPQ8074(4xA53@2.0Ghz)&lt;&#x2F;td&gt;&lt;td&gt;QCN5054+QCN5024&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;5Gbps&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;$479&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.h3c.com&#x2F;cn&#x2F;Products___Technology&#x2F;Products&#x2F;IP_Wlan&#x2F;Catalog&#x2F;AP&#x2F;802.11ax&#x2F;WA6628&#x2F;&quot;&gt;H3C WA6628 室内AP&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;IPQ8078&lt;&#x2F;td&gt;&lt;td&gt;QCN5154+QCN5124&lt;&#x2F;td&gt;&lt;td&gt;隐藏式&lt;&#x2F;td&gt;&lt;td&gt;10Gbps RJ45 POE&lt;&#x2F;td&gt;&lt;td&gt;1 POE&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Intel:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;WAV654：2x2 (2.4Gbps)
产品|Soc|WIFI芯片|天线数量|2.5Gbps WAN&#x2F;LAN|1Gbps WAN|1Gbps LAN|价格
-|-|-|-|-|-|-|-|
&lt;a href=&quot;https:&#x2F;&#x2F;item.jd.com&#x2F;100003753077.html&quot;&gt;Netgear RAX40 AX3000&lt;&#x2F;a&gt;|Intel (Lantiq) PXB4395 (800 MHz, 2 cores)|WAV654A0|2|0|1|4|￥1699&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ASUS RT-AX58U(已发布,暂未上市)&lt;&#x2F;li&gt;
&lt;li&gt;ASUS RT-AX82U(已发布,暂未上市)&lt;&#x2F;li&gt;
&lt;li&gt;TP-LINK Archer AX50(已发布,暂未上市)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;WAV624: 4x4&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ASUS RT-AX82U&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;intel-ax200ngw-mu-qian-wei-yi-zhi-chi-wifi6de-pcwu-xian-wang-qia&quot;&gt;Intel AX200NGW: 目前唯一支持WIFI6的PC无线网卡&lt;&#x2F;h2&gt;
&lt;p&gt;网络支持：802.11 a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac&#x2F;ax, Bluetooth 5.0&lt;&#x2F;p&gt;
&lt;p&gt;MIMO:2x2&lt;&#x2F;p&gt;
&lt;p&gt;最大速率:2.4Gbps(5GHz,1024QAM,160MHz)&lt;&#x2F;p&gt;
&lt;p&gt;频带：2.4GHz，5GHz(160MHz)&lt;&#x2F;p&gt;
&lt;p&gt;规格及接口：M.2 E key 2230(22mm x 30mm x 2.4mm),PCIe 3.0x1&lt;&#x2F;p&gt;
&lt;p&gt;支持的操作系统：Windows10 1903+，GNU&#x2F;Linux 5.1, ChromeOS&lt;&#x2F;p&gt;
&lt;p&gt;售价:￥65&#x2F;$10 (不含税)&lt;&#x2F;p&gt;
&lt;p&gt;变种：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;AX201，适用于支持CNVio2链路的芯片组(桌面端：Z390,B360,移动端：Whiskey Lake) 规格: M.2 2230 E key&lt;&#x2F;li&gt;
&lt;li&gt;Killer AX1650x，killer贴牌的AX200，包含Killer的专有驱动软件&lt;&#x2F;li&gt;
&lt;li&gt;AX200D2WL,M.2 1216 (12mm x 16mm x 1.65mm)嵌入式模块&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;product-briefs&#x2F;wi-fi-6-ax200-module-brief.pdf&quot;&gt;产品介绍&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ark.intel.com&#x2F;content&#x2F;www&#x2F;cn&#x2F;zh&#x2F;ark&#x2F;products&#x2F;189347&#x2F;intel-wi-fi-6-ax200.html&quot;&gt;产品规格&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wifi6-phone&quot;&gt;WIFI6 Phone&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;Samsung Galaxy S10、S10e、S10 5G：村田制作所（Murata）KM8D03042,包含Broadcom BCM4375&lt;&#x2F;li&gt;
&lt;li&gt;Samsung Galaxy Note10、Note10 5G：村田 1RH KM9515099 J05 3XAR27 Wi-Fi&#x2F;蓝牙模块&lt;&#x2F;li&gt;
&lt;li&gt;iPhone 11、11 Pro、11 Pro Max&lt;&#x2F;li&gt;
&lt;li&gt;华为 Mate 30（猜测）Android10，HiSilicon Hi1105(2019-09-04 WIFI联盟认证)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>使用Rust编写操作系统(三)</title>
            <pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/write-os-in-rust3/</link>
            <guid>https://12101111.github.io/write-os-in-rust3/</guid>
            <description>&lt;p&gt;本文主要解释PC平台的图形显示标准.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>使用Rust编写操作系统(二)</title>
            <pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/write-os-in-rust2/</link>
            <guid>https://12101111.github.io/write-os-in-rust2/</guid>
            <description>&lt;p&gt;众所周期,BIOS作为IBM PC工程师40年前随手写下的一段汇编代码,根本不会想到能用到现在.BIOS中充满了各种各样的hack和历史糟粕.BIOS只支持从MBR分区表的第一个扇区启动,很难安装到硬盘或U盘.甚至Intel即将于2020年在新的芯片上放弃对UEFI CSM的支持,这使得未来很难直接运行只支持BIOS的系统.可惜的是,直到今日,大多数自制x86平台操作系统的资料仍旧只支持BIOS。&lt;&#x2F;p&gt;
&lt;p&gt;本文试图基于Rust操作系统开发中读者广泛的blog os系列文章提供一个能够在UEFI上运行的教学用OS.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>计算机的旧事</title>
            <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/oldthing/</link>
            <guid>https://12101111.github.io/oldthing/</guid>
            <description>&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;hun-dun-yu-guang-ming&quot;&gt;混沌与光明&lt;&#x2F;h1&gt;
&lt;p&gt;17世纪,Pascal发明了第一个机械计算器.&lt;&#x2F;p&gt;
&lt;p&gt;19世纪初Babbage设计了差分机,Ada则成为世界上第一个计算机程序员.&lt;&#x2F;p&gt;
&lt;p&gt;20世纪初,数学家大卫希尔伯特提出了著名的23个问题,其中第二个问题为&amp;quot;判定一个公理系统内的命题是相容而无矛盾的&amp;quot;,第十个问题为,对于任意多个未知数的整系数不定方程(也称丢番图方程)是否存在一个&amp;quot;算法&amp;quot;,能在有限时间内判定该方程有无整数解.对第10问题的讨论,引出了对什么是&amp;quot;算法&amp;quot;,什么是&amp;quot;可计算&amp;quot;的讨论.随后,哥德尔证明了第二问题为假,即哥德尔不完备定理.随后,Alonzo Church和Alan Turing分别形式化的给出了证明,分别引出了λ演算和图灵机的概念.虽然λ演算先于图灵机提出,而且和图灵机等价,但是图灵机对当时的影响更大.图灵机中纸带和固定规则的概念深深的影响了真正的计算机.&lt;&#x2F;p&gt;
&lt;p&gt;二战中,国际商业机器公司(IBM)的机械制表机和打孔卡同时畅销于美国和纳粹德国.机械制表机的出现大大加快了美国人口普查及其他繁琐的数据统计工作的速度,打空卡也流行于政府和工业界.然而,机械制表机只能做特定的工作,没有通用性.&lt;&#x2F;p&gt;
&lt;p&gt;二战后,为了研究导弹技术,第一台通用电子计算机由美国陆军在宾夕法尼亚大学于1946年制造,即ENIAC(Electronic Numerical Integrator and Computer,电子数字积分计算机).ENIAC开始并没有存储器,在John von Neumann的建议下,加入了存储器.随后又出现了数个由大学,政府或商业公司开发的计算机,比如EDSAC ,Ferranti Mark 1(第一台商业生产的计算机),UNIVAC I（通用自动计算机,第一台大规模生产的计算机).&lt;&#x2F;p&gt;
&lt;p&gt;随着晶体管和集成电路的出现,计算机的使用开始普及.IBM成功的将计算机从科学和军事用途推广到商业用途,当时其产品有IBM 650,IBM 701,IBM 704等.最早的高级编程语言,FORTRAN和LISP 均为IBM 704开发,704也是第一台具有硬件浮点单元的计算机.IBM 704连同外设共10吨.有4K个32bit字的内存.这种为商业开发的计算机被称为大型机.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;da-xing-ji-yu-fen-shi-xi-tong&quot;&gt;大型机与分时系统&lt;&#x2F;h1&gt;
&lt;p&gt;在50年代和60年代,大型机常用打孔卡作为程序的输入方式(例如与IBM 704一起使用的IBM 711打孔卡读卡器,IBM 721打孔卡记录器),打印机作为结果的输出方式,磁芯作为内存(737磁芯存储单元),磁带和磁鼓作为二级存储(IBM 727磁带单元,IBM 753磁带控制单元)&lt;&#x2F;p&gt;
&lt;p&gt;早期的大型机一次只能运行一个程序.使用这种大型机,首先要在纸上编写程序(通常使用机器语言,后来IBM发明了FORTAN语言,并提供了编译器和库函数),随后打印到打孔卡上,程序所需要的数据使用打孔卡或磁带存储.用户将材料提交给计算机管理员,并缴费(大型机作为当时昂贵的计算资源,按运算时长收费!).&lt;&#x2F;p&gt;
&lt;p&gt;1955年,为了避免排队等待或是机器空闲,通用汽车的IBM 701大型机管理员编写了通用汽车操作系统.在监视程序的帮助下,计算机管理员提交一批任务后,计算机就会自动的执行,随后打印出结果,或者程序出错崩溃.出错的程序可以通过控制面板的指示灯,拨号盘和开关来进行调试,或者直接放弃执行.修改后的程序,就要第二天重新等待下一批.后来IBM 650引入一项功能,如果机器出现随机处理错误(硬件故障),则允许从错误的地方恢复.随后有各种批处理监视程序诞生,但是,用户需要一个多任务系统.&lt;&#x2F;p&gt;
&lt;p&gt;MIT在修改后的IBM7090大型机上制作了第一个分时系统:CTSS(兼容分时系统,兼容指兼容之前的程序),包含了现代操作系统的常见内容:多用户支持,命令行解释程序RUNCOM,文本编辑器QED,汇编器FAP.这个系统引发了研究者对分时系统的兴趣,但是其没有走出实验室.&lt;&#x2F;p&gt;
&lt;p&gt;MIT,通用电气和贝尔实验室于1964年开始开发Multics(多路复用信息和计算服务),一个为GE-645大型机开发的分时系统.该系统基于CTSS系统,并有许多创新,但是其复杂性和规模越来越大,贝尔实验室对此项目进展不满意,退出了该项目.通用电气继续开发,并成为自己的商业产品.&lt;&#x2F;p&gt;
&lt;p&gt;尽管有很多分时系统在60年代出现,但是大多都没有成为主流.一方面由于硬件架构经常变化,而对应的系统几乎没有可移植性,同时导致这些系统上的软件也没有可移植性,另一方面分时系统的效率较低,而且当时硬件的内存极小,很不适合共享.&lt;&#x2F;p&gt;
&lt;p&gt;IBM推出的IBM System&#x2F;360是当时(也是迄今为止)最成功的计算机之一,其首次提出配置的概念:System&#x2F;360家族硬件具有不同的处理能力和存储能力,但是具有相同的指令集,并且配件相互兼容.此款计算机上的程序甚至不需要修改就能在高配置的机器上运行,而且IBM保障了兼容性,即使有后续机型推出.IBM&#x2F;360刚发布时的程序也能在现在的IBM Z系列大型机上运行.&lt;&#x2F;p&gt;
&lt;p&gt;IBM在System&#x2F;360大型机上没有搭载分时系统.一方面IBM为了减小升级硬件的成本,设计了多个配置的System&#x2F;360,而较小内存的System&#x2F;360很难运行分时系统(内存最小仅4KB,而最大则有4MB).IBM提供了OS&#x2F;360这一多道程序系统.多道程序系统的程序进行IO时会切换到另一程序以最大化利用CPU.由于OS&#x2F;360开发时bug很多,IBM为了防止影响销售,提前为低端设备依次发布了BPS&#x2F;360(基本编程系统,用于8KB内存,至少有打孔卡读卡器的设备)BOS&#x2F;360(基本操作系统,用于8KB内存),TOS&#x2F;360(磁带操作系统,用于16KB内存带磁带驱动器的设备),DOS&#x2F;360(磁盘操作系统,用于16KB内存带磁盘驱动器的设备).一年后发布的OS&#x2F;360至少需要64KB内存,这导致占用资源较低的DOS&#x2F;360成为当时最流行的系统.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;cong-dian-bao-dao-dian-chuan-da-zi-ji-zai-dao-zhong-duan&quot;&gt;从电报到电传打字机再到终端&lt;&#x2F;h1&gt;
&lt;p&gt;时间再向前倒回19世纪,1837年,英国的库克和惠斯通在英国建立了13英里的电报系统,这是世界上第一部商业电报.同时在大洋对面,美国的摩尔斯发明了一种新型电报系统,其仅使用电流的通断及持续时间来编码信息，即摩尔斯电码.1844年,摩尔斯的电报系统在美国开始使用.1865年,改进后的国际莫尔斯码成为国际标准.但摩尔斯电码学习困难,很难被一般人熟练掌握,因此有人试图用各种机械按键来简化输入输出.Royal Earl House在1846年发明了一种打印电报,具有2个28键的键盘,发送方按下键后,接收方便打印这个键对应的字符.这个系统传输较慢,不能量产.1855年,David Edward Hughes(也是麦克风的发明人)改进了Royal Earl House的机器,发明了自己的印刷电报机,并组建了西部联合电报公司,他的电报系统成为当时欧洲的标准.1874年ÉmileBaudot发明了Baudot编码,并改进了Hughes电报系统,使其支持分时多路复用,并能自动编解码并打印字符,波特这个单位即纪念他.之后,电报的原始发明人惠斯通发明了惠斯通穿孔器,发报员首先使用机器将信息打印到打孔纸带上,随后被自动发报机以极高的速度发送.1903年,在Joy Morton的资助下,Charles L. Krum发明了轮式印刷电报机,并申请专利,随后二人成立Morkrum公司.1908年,Morkrum公司制作了一台电传打字机.1919年,Kleinschmidt也提交了相关专利,改进了轮式打印机的启停同步方法.为了避免专利纠纷,1924年Morkrum公司和Kleinschmidt的公司合并成Morkrum-Kleinschmidt公司,1928年又更名为Teletype公司,1930年被AT&amp;amp;T收购.电传(Telex)是二战后普遍的书面信息传输方式.电报是人类历史上第一个电子通信信方式,也是第一个无线通信方式,而电传打字机诞生了使用数字编码字符的方法.1963年,为了统一各种电传打印机的编码,美国标准协会制定了ASCII码,取代了Baudot码,Murray码及ITA2码.&lt;&#x2F;p&gt;
&lt;p&gt;而电传打字机,在计算机出现后,成为主流的输入设备.尤其是拥有分时操作系统的大型机,同时可以连接上千个电传打字机.大型机的用户可以使用电传打字机通过电传网络连接到主机,不必来到主机前.&lt;&#x2F;p&gt;
&lt;p&gt;1968年的计算机终端公司推出了自己也是世界上第一个终端Datapoint 3300.Datapoint 3300兼容Teletype Model 33,后者是当时最流行的ASCII电传打字机.而Datapoint 3300没有打印机,它将字符显示到显示器上,这样不仅噪音更低,而且节省纸张.&lt;&#x2F;p&gt;
&lt;p&gt;Datapoint 3300可以输出25行72列的纯大写字符,而且使用TTL芯片组装,没有内置RAM,而是使用54个200位位移寄存器输出图像.当时的RAM很贵,直到Intel公司于1970年发布1103,DRAM的价格才可以被接受.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;xiao-xing-ji-yu-unix&quot;&gt;小型机与Unix&lt;&#x2F;h1&gt;
&lt;p&gt;大型机主要为大商业公司和政府设计,可靠性很高,但是价格也以数十万美元起步,甚至达到数千万美元的硬件软件费用.高昂的售价实际上只适合于金融业和大型企业,大学和许多小公司根本无力购买.&lt;&#x2F;p&gt;
&lt;p&gt;数字设备公司(DEC)借机推出PDP系列计算机(Programmed Data Processor,程序数据处理器),“PDP”这个名称故意避免使用“计算机”这个术语，因为在第一台PDP之前，计算机是大型，复杂和昂贵的机器的意思.PDP性能远不如IBM的大型机,但体积小(接近于现在的柜式空调机大小),售价低(数万美元).后来这种计算机被称为小型机.小型机性能不高,经常用于程序开发,CAD或者自动控制.&lt;&#x2F;p&gt;
&lt;p&gt;贝尔实验室退出Multics项目后,曾经参与该项目的程序员Ken Thompson决定编写自己的操作系统,这个新系统要更高效,能在更低配置的机器上运行.他在实验室中找到了一个没有人用的PDP-7,在上面编写新的操作系统,还编写了一个叫&amp;quot;太空旅行&amp;quot;的游戏.1969年,由Ken Thompson和Dennis Ritchie领导的研究小组开发出的系统已经具有文件系统,进程,命令行解释器等概念和功能.随后,这个由汇编编写,具有编辑器,汇编器和shell的系统完成了自举(即自己编译自己).随后这个系统被命名为Unix.&lt;&#x2F;p&gt;
&lt;p&gt;1970年,贝尔实验室计算科学研究中心获得经费,Unix被移植到新购买的PDP-11上,并被其他部门广泛使用.1971年11月3日,Unix程序员手册第一版发布,也被认为是Unix第一版.&lt;&#x2F;p&gt;
&lt;p&gt;在将Unix从PDP-7移植到PDP-11时,Ken Thompson希望有一个高级语言来编写应用程序.Ken Thompson开发了基于BCPL的B语言.但是B语言比较慢,Dennis Ritchie改进了B,创造了C语言.1972年6月12日的第二个版本的Unix开始包含C编译器以及C编写的程序.1973年二月的第三版Unix中包含了C的调试器.&lt;&#x2F;p&gt;
&lt;p&gt;1973年11月的Unix第4版中,Unix的内核也由C语言编写.同年的操作系统原理研讨会上,Unix正式公开公布.估计有20台PDP-11安装此版本Unix.&lt;&#x2F;p&gt;
&lt;p&gt;1974年6月,AT&amp;amp;T将Unix第5版的源码授权给大学,由于条款十分严格,用户很少.此版本中还包含大量的PDP-11汇编.&lt;&#x2F;p&gt;
&lt;p&gt;1975年5月,第6版Unix以两万美元的价格出售,由于许可条款不限制分发源代码,因此此版本的Unix在大学间广泛传播.加州大学伯克利分校基于此发布了著名的伯克利软件发行版第一版(1 BSD).新南威尔士大学教授John Lions出版了图书《Unix第6版评论》,包括Unix第6版在PDP-11&#x2F;40上的代码,以及相关注释,用于操作系统教学.但是这本书被AT&amp;amp;T声称违反许可证而停止出售,但是各种复印版流传于计算机专业的大学生手中.&lt;&#x2F;p&gt;
&lt;p&gt;1975年,Unix Users Group成立,由于Unix是AT&amp;amp;T商标,后来改名为USENIX.&lt;&#x2F;p&gt;
&lt;p&gt;1977年,贝尔实验室采购了Interdata 8&#x2F;32 小型机,并将Unix移植到了此平台.这是Unix第一次运行在非DEC机器上.随后Unix又被移植到System&#x2F;370的虚拟机VM&#x2F;170中&lt;&#x2F;p&gt;
&lt;p&gt;1978年,Ken Thompson和Dennis Ritchie编写了一般介绍C语言的书籍《The C Programming Language》,直到1989年C语言第一个标准,这是C语言的事实标准.&lt;&#x2F;p&gt;
&lt;p&gt;1979年一月,第7版Unix发布,这是第一个可移植的版本,通过Dennis Ritchie开发的便携C编译器,该系统可以移植到许多平台.这也是最后一个由计算科学研究中心（CSRC）广泛发行的Unix.&lt;&#x2F;p&gt;
&lt;p&gt;1979年5月,2 BSD发布,并包含了著名的vi和C shell.有趣的是志愿者在2018年12月19日为BSD 2.11提交了一个安全补丁.&lt;&#x2F;p&gt;
&lt;p&gt;加州大学伯克利分校的学生重写了Unix内核,以利于VAX架构的虚拟内存的功能,1979年末发布了3 BSD.&lt;&#x2F;p&gt;
&lt;p&gt;Unix研究的主力,实际上来到了加州大学伯克利分校.CSRC后来发布的第八版Unix和第9版Unix都是基于BSD.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;di-yi-ge-wei-chu-li-qi-yu-dian-zi-ji-suan-qi&quot;&gt;第一个微处理器与电子计算器&lt;&#x2F;h1&gt;
&lt;p&gt;然而,即使是小型机,其价格和复杂性也不适合普通消费者.Unix在大学,企业,实验室直接流行,但普通消费者却从没有机会接触到计算机.正如计算机最早是用来计算数学问题的一样,真正做到人手一台的计算设备也是用与计算数学问题的,这就是电子计算器.&lt;&#x2F;p&gt;
&lt;p&gt;1968年,仙童八叛逆之二的罗伯特·诺伊斯、高登·摩尔离开仙童半导体，共同创办英特尔(Intel)公司,Intel是“集成电子”(INTegrated ELectronics)的缩写。著名的安迪·葛洛夫随后加入英特尔。Intel创建之时,其目标是生产替代磁芯存储器的半导体存储器.Intel的SRAM(静态随机存取存储器)非常成功,成为大型机主存的主流,随后又推出速度更快的DRAM(动态随机存取存储器)和ROM产品.但是随着日本半导体行业崛起,日本推出了价格更低的ROM和RAM产品，这导致Intel的营收大大降低.&lt;&#x2F;p&gt;
&lt;p&gt;由于某种巧合,1969年,日本的Nippon计算器公司联系Intel,为其Busicom打印计算器设计12个定制芯片,而Intel的工程师建议只需要4个芯片即可.1971年,Intel推出4个芯片:4001:RAM,4002:ROM,4003:用于I&#x2F;O的移位寄存器,4004:中央处理器.由于项目延期,Intel返还了部分费用,但是要求可以自由销售这些芯片.不同于过去使用多个专用ASIC芯片组成的计算器,4004允许通过编程来改变其功能,其代码保存在ROM中.第一款微处理器芯片由此诞生了.&lt;&#x2F;p&gt;
&lt;p&gt;4004由Federico Faggin独自设计,拥有2300个晶体管,10微米工艺,面积为12平方毫米,拥有16个4位寄存器,指令集有46个指令,支持3层嵌套调用,每秒可执行92000条指令.其性能超过了所有40年代的早期计算机.早期的计算器内部没有使用浮点数运算,而是使用BCD码进行运算,这一情况直到80年代IEEE-754浮点数标准通过才发生变化.因此Intel早期的CPU对BCD码提供了很好的支持.&lt;&#x2F;p&gt;
&lt;p&gt;4004之后,1974年，Intel推出改进版4040,增加了对中断、单步执行、ROM存储区切换的支持，并增加了用于中断的8个4位寄存器，用于调用和中断的栈深度增加到7层。&lt;&#x2F;p&gt;
&lt;p&gt;然而4004的性能不强,功能针对于BCD运算,因此只适合用于计算器.尽管如此,4004还被用作微控制器,比如控制桌上弹球游戏.&lt;&#x2F;p&gt;
&lt;p&gt;有些巧合的是,前面提到的CTC公司的Datapoint 3300终端由于使用了大量的TTL电路,发热量很大,CTC公司找到Intel和TI公司,希望他们能提供微处理器来实现终端的处理芯片.Intel将该计划中的芯片称为1201,这是世界上第一款8位微处理器,由CTC公司的Victor Poor和Pyle设计指令集和架构.然而TI发现Intel的设计不能制造出可用的芯片,因为此项目中Intel方面的工程师既不是芯片设计师也不是半导体工程师.CTC决定继续使用TTL实现,1970年,CTC的下一代产品Datapoint 2200发布,依旧使用大约100个TTL芯片,并且指令集兼容1201芯片.1971年1月,4004的设计师Federico Faggin对1201进行重新设计,并于1971年提交给CTC.不过CTC发现TTL实现的芯片比MOS集成电路要快,因此放弃了与Intel的合作,Intel没有得到5万美金的合同款,但是拥有芯片的知识产权.Intel随后将1201重新命名为8008,并于1972年4月以120美元的价格公开销售.&lt;&#x2F;p&gt;
&lt;p&gt;作为8008的兼容产品,CTC Datapoint 2200具有2K的内存(最大16K),能够显示80x12个字符,具有可选的磁带机和软盘驱动器,并且具有调制解调器,硬盘,打印机等外设.&lt;&#x2F;p&gt;
&lt;p&gt;实际上,Datapoint 2200可编程终端是世界上第一台个人电脑;Victor Poor和Pyle设计的指令集是现在X86指令集架构的祖先,他们的实现甚至早于Intel,但是公司并不希望此产品向这一方向发展.Datapoint 2200是一款相当热销的终端,因此公司改名为Datapoint.Datapoint公司80年代初成为财富500强企业,但是由于财务问题最终破产.&lt;&#x2F;p&gt;
&lt;p&gt;8008使用10微米PMOS工艺,具有3500个晶体管,7个8位寄存器和7层的栈寄存器,每秒执行36000到80000条指令,略慢于4004,但是一次处理8位数据的优势使其运算速度更快.由于8008的引脚只有18个,8008只有一个8位的总线,限制了8008作为通用处理器的能力.&lt;&#x2F;p&gt;
&lt;p&gt;走过了70年代,就到了堪比寒武纪大爆炸的80年代,家用计算机的辉煌时刻.&lt;&#x2F;p&gt;
&lt;p&gt;受篇幅原因,在另外一篇文章更新.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>使用Rust编写操作系统(一)</title>
            <pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/write-os-in-rust/</link>
            <guid>https://12101111.github.io/write-os-in-rust/</guid>
            <description>&lt;h1 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h1&gt;
&lt;p&gt;Rust语言作为C&#x2F;C++的安全替代,是21世纪新兴语言中最适合开发操作系统的.&lt;&#x2F;p&gt;
&lt;p&gt;本文介绍有关使用高级语言,Rust,编写操作系统的一些前置知识.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>在FydeOS上安装ArchLinux</title>
            <pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/install-archlinux-on-fydeos/</link>
            <guid>https://12101111.github.io/install-archlinux-on-fydeos/</guid>
            <description>&lt;h1 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h1&gt;
&lt;p&gt;FydeOS是一个国产的ChromiumOS发行版,是目前唯一像ChromeOS一样支持安装Android应用的ChromiumOS发行版.FydeOS像ChromeOS一样也支持运行Linux程序,但是默认的发行版是Debian,包又老又少,因此决定换Archlinux.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust学习资料</title>
            <pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/rustxue-xi-zi-liao/</link>
            <guid>https://12101111.github.io/rustxue-xi-zi-liao/</guid>
            <description>&lt;h1 id=&quot;guan-fang-ye-mian&quot;&gt;官方页面&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;zh-CN&#x2F;&quot;&gt;Rust 语言 官网&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&quot;&gt;Rust 语言 源代码&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;master&#x2F;RELEASES.md&quot;&gt;Rust 语言 发行说明&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;error-index.html&quot;&gt;Rust 编译错误代码索引&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;&quot;&gt;Crates.io&lt;&#x2F;a&gt; Rust 程序库(crate)托管服务&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;Docs.rs&lt;&#x2F;a&gt; 文档托管服务,所有Crates.io上crate的文档&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zhong-wen-zi-yuan&quot;&gt;中文资源&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kaisery.github.io&#x2F;trpl-zh-cn&#x2F;&quot;&gt;Rust 程序设计语言 第二版 中文版 (the book)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kaisery.gitbooks.io&#x2F;rust-book-chinese&#x2F;content&#x2F;&quot;&gt;Rust 程序设计语言 第一版 中文版 (the book)&lt;&#x2F;a&gt; (过时)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rustwiki.org&#x2F;zh-CN&#x2F;&#x2F;rust-by-example&#x2F;&quot;&gt;在实践中学 Rust&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;zh-CN&#x2F;faq.html&quot;&gt;常见问题解答 FAQ&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang-cn&#x2F;english-chinese-glossary-of-rust&#x2F;blob&#x2F;master&#x2F;rust-glossary.md&quot;&gt;Rust 语言术语中英文对照表&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Hello World Again And use gutenberg</title>
            <pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/hello-world/</link>
            <guid>https://12101111.github.io/hello-world/</guid>
            <description>&lt;p&gt;在使用hexo写了寥寥几篇文章后,我还是放弃了这个著名的静态博客程序.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>记一次git仓库损坏的经历</title>
            <pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/gitcang-ku-sun-pi/</link>
            <guid>https://12101111.github.io/gitcang-ku-sun-pi/</guid>
            <description>&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;bei-jing&quot;&gt;背景&lt;&#x2F;h1&gt;
&lt;p&gt;我的manjaro Linux滚动更新后nVidia显卡HDMI输出出现了问题,暂时无法解决,因此开发环境切换到Windows.环境搭建的很顺利.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wen-ti-de-chan-sheng&quot;&gt;问题的产生&lt;&#x2F;h1&gt;
&lt;p&gt;今日在执行git commit时提交的信息中包含了大量垃圾信息(换行符从LF换掉CRLF)又没有注意到,提交后发现commit message与我预想的不对,随后又发现所有行后面都加上了Windows的换行符,因此打算撤回这次commit,更改换行符到LF再重新commit.于是终端中执行.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#fdf6e3;color:#657b83;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#b58900;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; log
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b58900;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; reset&lt;&#x2F;span&gt;&lt;span style=&quot;color:#268bd2;&quot;&gt; --mixed &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;commit-hash&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;理论上执行很快就能完成,但不巧的是Windows卡住然后蓝屏了,经调查蓝屏原因是nvme SSD接口故障.硬盘错误可能会导致数据损坏,果然,再打开仓库时,git说这不是一个有效的git仓库&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;output&quot; style=&quot;background-color:#fdf6e3;color:#657b83;&quot; class=&quot;language-output &quot;&gt;&lt;code class=&quot;language-output&quot; data-lang=&quot;output&quot;&gt;&lt;span&gt;$ git status
&lt;&#x2F;span&gt;&lt;span&gt;fatal: 不是一个 git 仓库（或者向上递归至挂载点 &#x2F;mnt 的任何祖先目录）
&lt;&#x2F;span&gt;&lt;span&gt;停止在文件系统边界（未设置 GIT_DISCOVERY_ACROSS_FILESYSTEM）
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然而&lt;code&gt;.git&lt;&#x2F;code&gt;文件夹还在那里,推测git仓库的部分文件损坏.由于最近两次的commit都没有提交,因此需要从这些文件中找回写过的代码,要不然就要重写.&lt;&#x2F;p&gt;
&lt;!--more--&gt;
&lt;p&gt;查看损坏的repo中workspace中的文件,全部变成了乱码的二进制文件.找到Linux中的历史版本,使用diff工具比较&lt;code&gt;.git&lt;&#x2F;code&gt;,&lt;code&gt;objects&lt;&#x2F;code&gt;文件夹即为数据文件, 不要更改, 查找其他乱码的文件, 发现以下文件损坏, 使用旧仓库的覆盖.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;.git&#x2F;index&lt;&#x2F;li&gt;
&lt;li&gt;.git&#x2F;config&lt;&#x2F;li&gt;
&lt;li&gt;.git&#x2F;HEAD&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;.git&#x2F;HEAD&lt;&#x2F;code&gt;的内容为&lt;code&gt;ref: refs&#x2F;heads&#x2F;master&lt;&#x2F;code&gt;, 打开正常仓库的&lt;code&gt;.git&#x2F;refs&#x2F;heads&#x2F;master&lt;&#x2F;code&gt;, 里面为commit-hash, 打开损坏仓库的&lt;code&gt;.git&#x2F;logs&#x2F;refs&#x2F;heads&#x2F;master&lt;&#x2F;code&gt;, 发现内容正常, 为commit的历史, 将最后一次的hash复制到&lt;code&gt;.git&#x2F;refs&#x2F;heads&#x2F;master&lt;&#x2F;code&gt;, 再执行&lt;code&gt;git reset --hard &amp;lt;commit-hash&amp;gt;&lt;&#x2F;code&gt;, 文件成功恢复.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ti-xing&quot;&gt;提醒&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;.git&lt;&#x2F;code&gt;中的文件在正常情况下不要手动修改, 除非出现这种事故.&lt;&#x2F;p&gt;
&lt;p&gt;本地仓库commit后就应该push到远程仓库, 防止文件损坏.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust语言介绍</title>
            <pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/rustyu-yan-jie-shao/</link>
            <guid>https://12101111.github.io/rustyu-yan-jie-shao/</guid>
            <description>&lt;p&gt;From Wikipedia：Rust是一个由Mozilla主导开发的通用、编译型编程语言。它的设计准则为“安全，并发，实用”，支持函数式，并发式，过程式以及面向对象的编程风格。Rust的语法与C++相似（我不这么认为），但它在维持高性能的情况下能保证内存安全。&lt;&#x2F;p&gt;
&lt;p&gt;Rust语言官网：Rust 是一种系统编程语言。 它有着惊人的运行速度，能够防止段错误，并保证线程安全。&lt;&#x2F;p&gt;
&lt;p&gt;Rust连续3年在stackoverflow &lt;a href=&quot;https:&#x2F;&#x2F;insights.stackoverflow.com&#x2F;survey&#x2F;2018&#x2F;#most-loved-dreaded-and-wanted&quot;&gt;年度调查&lt;&#x2F;a&gt;中被评为最受喜爱的编程语言(the most loved programming language。)&lt;&#x2F;p&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;liigo&#x2F;article&#x2F;details&#x2F;45757123&quot;&gt;为什么我说Rust是靠谱的编程语言 by Liigo&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>遇到Windows蓝屏的解决思路</title>
            <pubDate>Wed, 28 Feb 2018 00:00:00 +0000</pubDate>
            <link>https://12101111.github.io/bluescreen/</link>
            <guid>https://12101111.github.io/bluescreen/</guid>
            <description>&lt;h2 id=&quot;shi-yao-shi-lan-ping&quot;&gt;什么是蓝屏&lt;&#x2F;h2&gt;
&lt;p&gt;蓝屏，英语　Blue Screen of Death，缩写为：BSoD，又称为bugcheck。表现为系统突然停止响应，屏幕上出现蓝色背景的错误信息。在Windows7及之前的版本中，蓝屏为深蓝色，并含有大段英文的解决方案，告诉用户检查硬件是否正常，并建议用户卸载或移除新安装的软硬件。由于该界面过于不友好，且这段解决方案很少能解决问题，微软在Windows8及之后的版本将蓝屏改为浅蓝色背景，并显示:( 你的电脑遇到问题需要重启,以及一个没有用的二维码。&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
